# 弥散霓虹风格实现指南

> 基于 CoScroll MVP 框架的"Dreamy Grain Glow"风格具体实践方案

## 📋 项目当前状态分析

### ✅ 已完成的基础架构
- ✅ 项目已成功运行在 `http://localhost:3001`
- ✅ Next.js 14 + TypeScript + Three.js 基础框架
- ✅ `@react-three/postprocessing` 已安装 (弥散效果必需)
- ✅ 完整的组件架构和状态管理

### 🔧 需要修复的技术问题
根据日志分析，需要优先解决：
- 🔄 Tone.js API 导入错误 (tone.start, tone.context 等)
- 🔄 中文字体文件缺失 (`/fonts/chinese-font.woff`)
- 🔄 音频初始化问题

### 🎨 视觉效果目标
基于参考图片和GPT风格建议，目标实现：
- **弥散发光**: Matcap + Fresnel + Bloom 组合
- **霓虹渐变**: 粉橙 (#ff6b9d) ↔ 青蓝 (#4ecdc4) 过渡
- **颗粒质感**: Film Grain + Dither 掩饰低模瑕疵
- **呼吸动效**: 滚动驱动的光晕强度变化

### 🎯 布局架构设计
**三层分离架构**：
1. **底层**: 背景 WebGL (弥散霓虹效果)
2. **中层**: 锚字区 (2/3 宽度, 3D书法模型)
3. **上层**: 字幕区 (1/3 宽度, 滚动文本)

---

## 🎨 弥散霓虹风格实现方案

## 🏗️ 心经文本结构

### 段落分解 (基于1_心经拆解.md)
```json
[
  { "id": 1, "text": "照见五蕴皆空，度一切苦厄。", "anchor": "空" },
  { "id": 2, "text": "色不异空，空不异色；色即是空，空即是色。", "anchor": "色" },
  { "id": 3, "text": "是诸法空相：不生不灭，不垢不净，不增不减。", "anchor": "心" },
  { "id": 4, "text": "是故空中无色，无受想行识；无眼耳鼻舌身意；无色声香味触法；无眼界乃至无意识界。", "anchor": "无" },
  { "id": 5, "text": "无无明，亦无无明尽。", "anchor": "明" },
  { "id": 6, "text": "乃至无老死，亦无老死尽。", "anchor": "老" },
  { "id": 7, "text": "无苦集灭道，无智亦无得。", "anchor": "苦" }
]
```

### 🎭 全新交互设计方案

#### **自动播放 + 滚动控制系统**
**核心理念**：将滚动重新定义为播放控制，而非传统的页面浏览

**交互逻辑**：
- **自动播放**：默认按段落自动切换，每段完成1-2圈旋转
- **滚动控制**：
  - 向下滚动 = 加速播放
  - 向上滚动 = 减速播放
  - 快速滚动 = 跳转到进度条位置
  - 不滚动 = 正常播放速度

#### **段落切换动画系统**
**旋转规则**：
- **短段落** (≤30字)：1圈旋转 (360°)
- **长段落** (>30字)：2圈旋转 (720°)
- 旋转速度根据播放速度动态调整

**切换动画序列**：
1. **上浮消失** (1秒)：当前锚字 + 字幕同步向上滑出视野
2. **呼吸停顿** (0.5秒)：空白期，营造节奏感
3. **下滑出现** (1秒)：新锚字从下方滑入中央位置

**时间控制**：
```typescript
const segmentDuration = {
  short: 15000,  // 短段落 15秒
  long: 25000    // 长段落 25秒
}
// 实际时长 = 基础时长 / 播放速度
```

#### **文字交替显示逻辑** (保持原有设计)
**交错布局原则** (相对于中心锚字)：
- 第1行：前半句在前，后半句在后
- 第2行：前半句在后，后半句在前
- 第3行：前半句在前，后半句在后
- ...以此类推交错进行

**文字深度层次**：
- 前方文字：Z=1 (靠近观察者)
- 锚字模型：Z=0 (视觉焦点)
- 后方文字：Z=-1 (位于模型后方)
- 透明度：前方 0.9，后方 0.7 (营造深度感)

---

## 🚀 新版实施计划

### 阶段一：自动播放核心框架 (2-3天)

#### 1.1 搭建播放控制系统

**创建播放控制 Hook**：
```typescript
// src/hooks/usePlaybackControl.ts
export function usePlaybackControl() {
  const [currentSegmentIndex, setCurrentSegmentIndex] = useState(0)
  const [playbackSpeed, setPlaybackSpeed] = useState(1.0)
  const [isAutoPlaying, setIsAutoPlaying] = useState(true)

  // 滚动影响播放速度
  const { scrollVelocity } = useScrollStore()
  useEffect(() => {
    const newSpeed = Math.max(0.2, Math.min(3.0, 1.0 + scrollVelocity * 0.5))
    setPlaybackSpeed(newSpeed)
  }, [scrollVelocity])

  return { currentSegmentIndex, playbackSpeed, isAutoPlaying }
}
```

#### 1.2 段落自动切换系统

**时间控制逻辑**：
```typescript
// src/hooks/useSegmentTimer.ts
export function useSegmentTimer() {
  const { currentSegment, playbackSpeed } = usePlaybackControl()

  // 根据段落长度计算停留时间
  const getSegmentDuration = (text: string) => {
    const isLong = text.length > 30
    const baseDuration = isLong ? 25000 : 15000
    return baseDuration / playbackSpeed
  }

  // 自动切换到下一段
  const autoAdvance = () => {
    const duration = getSegmentDuration(currentSegment.text)
    setTimeout(() => {
      setCurrentSegmentIndex(prev => (prev + 1) % heartSutraSegments.length)
    }, duration)
  }
}
```

#### 1.3 移除手动旋转控制

**清理 OrbitControls**：
- 从 `AnchorGlyphRegion.tsx` 移除 `<OrbitControls>`
- 确保模型只能自动旋转，无法手动操作
- 保留开发模式下的调试功能（可选）

### 阶段二：段落切换动画系统 (2-3天)

#### 2.1 3D模型切换动画

**旋转动画控制**：
```typescript
// src/components/core/Model3D.tsx 增强
export default function Model3D({ anchorChar, playbackSpeed }: Model3DProps) {
  const modelRef = useRef<THREE.Group>(null)
  const [rotationProgress, setRotationProgress] = useState(0)

  // 计算旋转圈数
  const getRotationCycles = (char: string, textLength: number) => {
    return textLength > 30 ? 2 : 1  // 长段落2圈，短段落1圈
  }

  // 段落内持续旋转
  useFrame((state, delta) => {
    if (modelRef.current) {
      const rotationSpeed = (playbackSpeed * delta) / segmentDuration
      modelRef.current.rotation.y += rotationSpeed * Math.PI * 2 * cycles
    }
  })
}
```

#### 2.2 上浮下滑动画序列

**切换动画组件**：
```typescript
// src/components/animations/SegmentTransition.tsx
export function SegmentTransition({
  currentSegment,
  nextSegment,
  isTransitioning
}: TransitionProps) {

  const transitionSequence = {
    fadeOut: 1000,    // 上浮消失
    pause: 500,       // 呼吸停顿
    fadeIn: 1000      // 下滑出现
  }

  return (
    <AnimatePresence mode="wait">
      {isTransitioning ? (
        <motion.div
          initial={{ y: 0, opacity: 1 }}
          animate={{ y: -100, opacity: 0 }}
          exit={{ y: 100, opacity: 0 }}
          transition={{ duration: 1.5 }}
        >
          {/* 切换动画内容 */}
        </motion.div>
      ) : (
        <motion.div
          initial={{ y: 100, opacity: 0 }}
          animate={{ y: 0, opacity: 1 }}
          transition={{ duration: 1.0 }}
        >
          {/* 当前段落内容 */}
        </motion.div>
      )}
    </AnimatePresence>
  )
}
```

#### 2.3 字幕同步动画

**三层布局动画协调**：
- 锚字3D模型：上浮消失 + 下滑出现
- 字幕文本：同步上浮消失 + 下滑出现
- 背景效果：平滑过渡，保持连续性

### 阶段三：弥散霓虹视觉效果 (2-3天)

**问题**：`/fonts/chinese-font.woff` 404错误
**解决方案**：
```bash
# 创建字体目录
mkdir -p public/fonts/

# 临时解决方案：使用系统字体fallback
# 更新 src/app/globals.css
```

```css
/* src/app/globals.css 字体配置 */
@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;700&display=swap');

html {
  font-family: 'Noto Sans SC', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
}

.chinese-text {
  font-family: 'Noto Sans SC', serif;
  font-weight: 400;
  letter-spacing: 0.1em;
}
```

#### 1.3 实现基础 Shader 材质 (锚字模型)

**目标**：为锚字3D模型添加弥散发光效果

```typescript
// src/components/core/Model3D.tsx 增强
import { useRef, useEffect } from 'react'
import { useFrame } from '@react-three/fiber'
import { useGLTF } from '@react-three/drei'
import * as THREE from 'three'

export default function Model3D() {
  const modelRef = useRef<THREE.Group>(null)
  const { scene } = useGLTF('/models/10k/003_道.glb')
  
  // 创建 Matcap 材质
  const matcapTexture = new THREE.TextureLoader().load('/textures/matcap-warm.png')
  const matcapMaterial = new THREE.MeshMatcapMaterial({ 
    matcap: matcapTexture,
    transparent: true,
    opacity: 0.9
  })
  
  // 创建 Fresnel 效果材质
  const fresnelMaterial = new THREE.ShaderMaterial({
    uniforms: {
      fresnelPower: { value: 2.0 },
      rimColor: { value: new THREE.Color(0xff6b9d) },
      baseColor: { value: new THREE.Color(0x4ecdc4) }
    },
    vertexShader: `
      varying vec3 vNormal;
      varying vec3 vPosition;
      void main() {
        vNormal = normalize(normalMatrix * normal);
        vPosition = position;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform float fresnelPower;
      uniform vec3 rimColor;
      uniform vec3 baseColor;
      varying vec3 vNormal;
      varying vec3 vPosition;
      
      void main() {
        vec3 viewDirection = normalize(cameraPosition - vPosition);
        float fresnel = 1.0 - max(0.0, dot(vNormal, viewDirection));
        fresnel = pow(fresnel, fresnelPower);
        
        vec3 color = mix(baseColor, rimColor, fresnel);
        gl_FragColor = vec4(color, 0.8);
      }
    `,
    transparent: true
  })
  
  // 应用材质到模型
  useEffect(() => {
    if (modelRef.current) {
      modelRef.current.traverse((child) => {
        if (child instanceof THREE.Mesh) {
          child.material = fresnelMaterial
        }
      })
    }
  }, [])
  
  return <primitive ref={modelRef} object={scene} />
}
```

#### 1.2 添加基础光照系统

```typescript
// src/components/core/ScrollCanvas.tsx 光照增强
<Canvas>
  {/* 环境光 - 柔和基础照明 */}
  <ambientLight intensity={0.3} color="#ff6b9d" />
  
  {/* 主光源 - 温暖方向光 */}
  <directionalLight 
    position={[5, 5, 5]} 
    intensity={0.8} 
    color="#ff9a8b"
    castShadow
  />
  
  {/* 补光 - 冷色调补光 */}
  <directionalLight 
    position={[-5, -5, -5]} 
    intensity={0.4} 
    color="#4ecdc4"
  />
  
  {/* 点光源 - 动态呼吸光 */}
  <pointLight 
    position={[0, 0, 3]} 
    intensity={0.6} 
    color="#ff6b9d"
    distance={10}
  />
</Canvas>
```

### 第二阶段：三层布局架构 (3-4天)

**基于GPT建议的"三层分离架构"**：根据参考资料，需要实现：
- 底层：背景WebGL渲染(弥散霓虹效果)
- 中层：锚字区域(2/3宽度，书法3D模型)
- 上层：字幕区域(1/3宽度，滚动文本)

这个架构确保了视觉层次分明，交互流畅。

#### 2.1 实现三层分离布局

**布局结构**：
```typescript
// src/components/layout/DreamyLayout.tsx
export default function DreamyLayout() {
  return (
    <div className="relative w-full h-screen overflow-hidden">
      {/* 底层：背景 WebGL */}
      <div className="absolute inset-0 z-0">
        <BackgroundCanvas />
      </div>

      {/* 中层：锚字区 (2/3 宽度) */}
      <div className="absolute left-0 top-0 w-2/3 h-full z-10">
        <AnchorGlyphRegion />
      </div>

      {/* 上层：字幕区 (1/3 宽度) */}
      <div className="absolute right-0 top-0 w-1/3 h-full z-20 bg-gradient-to-l from-black/60 to-transparent backdrop-blur-sm">
        <SubtitlesPane />
      </div>

      {/* 文字深度层 - 前方文字 */}
      <div className="absolute left-0 top-0 w-2/3 h-full z-15 pointer-events-none">
        <FrontText className="opacity-90" />
      </div>

      {/* 文字深度层 - 后方文字 */}
      <div className="absolute left-0 top-0 w-2/3 h-full z-5 pointer-events-none">
        <BackText className="opacity-70" />
      </div>
    </div>
  )
}
```

#### 2.2 添加弥散后期处理效果

**实现 Bloom + Film Grain**：
```typescript
// src/components/core/BackgroundCanvas.tsx
import { EffectComposer, Bloom, Noise } from '@react-three/postprocessing'
import { BlendFunction } from 'postprocessing'

export default function BackgroundCanvas() {
  const { scrollVelocity } = useScrollStore()

  return (
    <Canvas>
      {/* 弥散背景几何 */}
      <DreamyBackground />

      {/* 后期处理管线 */}
      <EffectComposer>
        {/* 核心 Bloom 效果 */}
        <Bloom
          intensity={0.8 + scrollVelocity * 0.4}
          luminanceThreshold={0.15}
          luminanceSmoothing={0.95}
          mipmapBlur={true}
          blendFunction={BlendFunction.SCREEN}
        />

        {/* Film Grain 颗粒质感 */}
        <Noise
          premultiply
          blendFunction={BlendFunction.MULTIPLY}
          opacity={0.3}
        />
      </EffectComposer>
    </Canvas>
  )
}
```

#### 2.2 添加颗粒质感 (Film Grain)

```typescript
// src/components/core/ScrollCanvas.tsx
import { FilmGrain } from '@react-three/postprocessing'

<EffectComposer>
  <Bloom />
  <FilmGrain
    intensity={0.3}
    opacity={0.1}
  />
</EffectComposer>
```

#### 2.3 添加雾化效果

```typescript
// src/components/core/ScrollCanvas.tsx
import { Fog } from '@react-three/drei'

<Canvas>
  <fog attach="fog" args={['#ff6b9d', 5, 20]} />
  {/* 其他内容 */}
</Canvas>
```

### 第三阶段：滚动驱动效果 (2-3天)

#### 3.1 增强 useSync Hook

```typescript
// src/hooks/useSync.ts 增强
import { useScrollStore } from '@/stores/scrollStore'
import { useAudioStore } from '@/stores/audioStore'
import { useEffect } from 'react'

export function useSync() {
  const { scrollVelocity, scrollProgress } = useScrollStore()
  const { setPlaybackRate } = useAudioStore()
  
  useEffect(() => {
    // 滚动速度驱动音频播放速度
    const playbackRate = 0.5 + scrollVelocity * 0.5 // 0.5x - 1.5x 范围
    setPlaybackRate(Math.max(0.5, Math.min(1.5, playbackRate)))
    
    // 滚动进度驱动模型旋转
    const rotationY = scrollProgress * Math.PI * 2
    // 这里需要与 Model3D 组件通信
    
  }, [scrollVelocity, scrollProgress])
}
```

#### 3.2 动态材质参数

```typescript
// src/components/core/Model3D.tsx 动态参数
export default function Model3D() {
  const { scrollVelocity } = useScrollStore()
  
  useFrame((state) => {
    if (fresnelMaterial.current) {
      // 滚动驱动 Fresnel 强度
      fresnelMaterial.current.uniforms.fresnelPower.value = 1.5 + scrollVelocity * 1.0
      
      // 滚动驱动发光颜色
      const intensity = 0.5 + scrollVelocity * 0.5
      fresnelMaterial.current.uniforms.rimColor.value.setHSL(0.9, 0.8, intensity)
    }
  })
}
```

### 第四阶段：渐变色彩映射 (2天)

#### 4.1 创建渐变 LUT 纹理

```typescript
// src/utils/colorGradient.ts
export function createGradientLUT() {
  const canvas = document.createElement('canvas')
  canvas.width = 256
  canvas.height = 1
  const ctx = canvas.getContext('2d')!
  
  const gradient = ctx.createLinearGradient(0, 0, 256, 0)
  gradient.addColorStop(0, '#ff6b9d') // 粉橙
  gradient.addColorStop(0.5, '#ff9a8b') // 过渡色
  gradient.addColorStop(1, '#4ecdc4') // 青蓝
  
  ctx.fillStyle = gradient
  ctx.fillRect(0, 0, 256, 1)
  
  return new THREE.CanvasTexture(canvas)
}
```

#### 4.2 应用渐变到材质

```typescript
// src/components/core/Model3D.tsx
const gradientLUT = createGradientLUT()

const gradientMaterial = new THREE.ShaderMaterial({
  uniforms: {
    gradientMap: { value: gradientLUT },
    scrollProgress: { value: 0 }
  },
  // ... shader 代码
})
```

---

## 🚀 具体实施计划 (修订版)

### 🔥 立即行动项 (1-2天) - 修复运行错误
- [ ] 修复 Tone.js API 导入错误 (useAudio.ts:26,35,44,53)
- [ ] 解决中文字体文件404错误
- [ ] 确认基础页面可正常运行
- [ ] 验证三层布局架构可行性

### 第1周：基础材质和三层布局
- [ ] 为 `003_道.glb` 模型添加 Matcap 材质
- [ ] 实现 Fresnel 边缘发光效果
- [ ] 实现三层分离布局 (背景/锚字/字幕)
- [ ] 添加文字深度层次显示 (前方/后方文字)
- [ ] 配置基础光照系统

### 第2周：弥散发光后期处理
- [ ] 实现 Bloom 光晕效果 (已有 @react-three/postprocessing)
- [ ] 添加 Film Grain 颗粒质感
- [ ] 配置霓虹渐变色彩 (粉橙↔青蓝)
- [ ] 实现滚动驱动的光效强度变化

### 第3周：心经文本交替逻辑
- [ ] 实现基于锚字的文本分段显示
- [ ] 添加前后文字交替逻辑 (奇偶行反转)
- [ ] 同步音频播放速度与滚动速度
- [ ] 测试整体交互流畅性

### 第4周：视觉优化和设备适配
- [ ] 性能优化和移动端降级方案
- [ ] 添加呼吸光效 (段落切换时)
- [ ] 最终视觉效果调优
- [ ] 用户体验测试和修正

---

## 🔧 具体实现细节

### 心经文本实现逻辑

**基于1_心经拆解.md的数据结构**：
```typescript
// src/data/heartSutra.ts
export const heartSutraSegments = [
  { id: 1, text: "照见五蕴皆空，度一切苦厄。", anchor: "空" },
  { id: 2, text: "色不异空，空不异色；色即是空，空即是色。", anchor: "色" },
  { id: 3, text: "是诸法空相：不生不灭，不垢不净，不增不减。", anchor: "心" },
  { id: 4, text: "是故空中无色，无受想行识；无眼耳鼻舌身意；无色声香味触法；无眼界乃至无意识界。", anchor: "无" },
  { id: 5, text: "无无明，亦无无明尽。", anchor: "明" },
  { id: 6, text: "乃至无老死，亦无老死尽。", anchor: "老" },
  { id: 7, text: "无苦集灭道，无智亦无得。", anchor: "苦" }
]

// 文本分割逻辑
export function splitTextByAnchor(text: string, anchor: string) {
  const anchorIndex = text.indexOf(anchor)
  if (anchorIndex === -1) return { front: text, back: '' }

  return {
    front: text.substring(0, anchorIndex),
    back: text.substring(anchorIndex + anchor.length)
  }
}

// 交替显示逻辑
export function getTextLayout(segmentId: number) {
  const isEven = segmentId % 2 === 0
  return {
    frontZ: isEven ? -1 : 1,  // 偶数行：前文在后，奇数行：前文在前
    backZ: isEven ? 1 : -1,   // 偶数行：后文在前，奇数行：后文在后
    frontOpacity: isEven ? 0.7 : 0.9,
    backOpacity: isEven ? 0.9 : 0.7
  }
}
```

### 三层响应式布局实现

```typescript
// src/components/layout/ResponsiveLayout.tsx
export default function ResponsiveLayout() {
  const [isMobile, setIsMobile] = useState(false)

  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth < 768)
    checkMobile()
    window.addEventListener('resize', checkMobile)
    return () => window.removeEventListener('resize', checkMobile)
  }, [])

  if (isMobile) {
    return (
      <div className="flex flex-col h-screen">
        {/* 移动端：上下堆叠 */}
        <div className="flex-1 relative">
          <BackgroundCanvas />
          <AnchorGlyphRegion />
        </div>
        <div className="h-1/3 bg-black/60">
          <SubtitlesPane />
        </div>
      </div>
    )
  }

  return (
    <div className="relative w-full h-screen overflow-hidden">
      {/* 桌面端：左右分离 */}
      <div className="absolute inset-0 z-0">
        <BackgroundCanvas />
      </div>
      <div className="absolute left-0 top-0 w-2/3 h-full z-10">
        <AnchorGlyphRegion />
      </div>
      <div className="absolute right-0 top-0 w-1/3 h-full z-20">
        <SubtitlesPane />
      </div>
    </div>
  )
}
```

---

## 🎯 性能优化策略

### 移动端降级方案
```typescript
// src/utils/deviceDetection.ts
export function getDeviceCapabilities() {
  const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
  const isLowEnd = navigator.hardwareConcurrency < 4
  
  return {
    enableBloom: !isMobile && !isLowEnd,
    enableGrain: !isLowEnd,
    particleCount: isMobile ? 1000 : 10000,
    bloomIterations: isMobile ? 1 : 3
  }
}
```

### 渲染性能监控
```typescript
// src/hooks/usePerformance.ts
export function usePerformance() {
  const [fps, setFps] = useState(60)
  
  useFrame(() => {
    // 监控帧率
    const now = performance.now()
    const delta = now - lastTime
    setFps(1000 / delta)
    lastTime = now
    
    // 自动降级
    if (fps < 30) {
      // 降低效果质量
    }
  })
}
```

---

## 📱 响应式布局调整

### 桌面端 (≥1024px)
- 锚字区：60% 宽度
- 字幕区：40% 宽度
- 完整后期处理效果

### 平板端 (768px - 1024px)
- 锚字区：50% 宽度
- 字幕区：50% 宽度
- 中等后期处理效果

### 移动端 (≤768px)
- 纵向堆叠布局
- 锚字区在上方
- 字幕区在下方
- 基础后期处理效果

---

## 🔧 开发工具和调试

### 性能监控面板
```typescript
// src/components/debug/PerformancePanel.tsx
export function PerformancePanel() {
  const { fps, memory } = usePerformance()
  
  return (
    <div className="fixed top-4 right-4 bg-black/50 text-white p-2 rounded">
      <div>FPS: {fps}</div>
      <div>Memory: {memory}MB</div>
    </div>
  )
}
```

### 材质参数调试
```typescript
// src/components/debug/MaterialDebugger.tsx
export function MaterialDebugger() {
  const [fresnelPower, setFresnelPower] = useState(2.0)
  const [bloomIntensity, setBloomIntensity] = useState(0.5)
  
  return (
    <div className="fixed bottom-4 left-4 bg-black/50 text-white p-4 rounded">
      <div>
        <label>Fresnel Power: {fresnelPower}</label>
        <input 
          type="range" 
          min="0" 
          max="5" 
          step="0.1"
          value={fresnelPower}
          onChange={(e) => setFresnelPower(Number(e.target.value))}
        />
      </div>
      {/* 更多调试控件 */}
    </div>
  )
}
```

---

## 📋 验收标准

### 视觉效果验收
- [ ] 模型具有柔和的边缘发光效果
- [ ] 滚动时材质参数动态变化
- [ ] Bloom 光晕效果自然
- [ ] 颗粒质感适中，不过度
- [ ] 渐变色彩过渡平滑

### 性能验收
- [ ] 桌面端保持 60fps
- [ ] 移动端保持 45fps 以上
- [ ] 内存使用合理 (<200MB)
- [ ] 加载时间 <3秒

### 交互验收
- [ ] 滚动响应延迟 <100ms
- [ ] 音频同步精度 <200ms
- [ ] 视觉效果与滚动速度匹配
- [ ] 段落切换时的呼吸效果

---

## 🎉 预期效果

实现完成后，CoScroll 将呈现：

1. **空灵质感**：模型具有柔和的发光边缘，仿佛由光线构成
2. **动态响应**：滚动时材质、光照、后期效果实时变化
3. **颗粒质感**：整体画面具有胶片颗粒感，增加艺术氛围
4. **色彩渐变**：从粉橙到青蓝的平滑色彩过渡
5. **性能稳定**：在各种设备上都能流畅运行

这个实现方案完全基于您现有的 MVP 架构，整合了：
- **心经拆解数据** (1_心经拆解.md)
- **GPT风格建议** (三层分离架构)
- **浏览器错误日志** (Tone.js和字体问题)
- **用户反馈要求** (确认设计、标记完成状态)

只需要在现有组件基础上进行增强，不会破坏已有的功能结构。

---

## ⚡ 紧急修复清单

### 必须立即解决的问题
1. **Tone.js API错误** (`src/hooks/useAudio.ts`)
   - 修复 `tone.start` → `Tone.start()`
   - 修复 `tone.context` → `Tone.getContext()`
   - 修复 `tone.Reverb` → `new Tone.Reverb()`
   - 修复 `tone.Player` → `new Tone.Player()`

2. **字体文件404错误**
   - 添加 Google Fonts fallback
   - 配置中文字体栈
   - 确保文字正常显示

3. **TODO状态管理**
   - 及时标记已完成任务为 ✅
   - 跟踪当前进度状态
   - 确保项目里程碑可见

### 验证要求
完成修复后，应能看到：
- ✅ 开发服务器无错误运行
- ✅ 中文字符正常显示
- ✅ 音频系统正常初始化
- ✅ 三层布局基础架构可见

---

> **下一步行动**：
> 1. **立即修复**：解决 Tone.js 和字体错误
> 2. **确认设计**：与你确认背景、文字、选段的具体实现方案
> 3. **开始开发**：基于确认的设计开始弥散霓虹风格实现
> 4. **迭代优化**：逐步添加后期处理效果和交互逻辑
>
> **重要**：每完成一个阶段都会及时更新TODO状态，确保进度透明可控。
