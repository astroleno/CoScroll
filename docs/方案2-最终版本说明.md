# 方案2实现 - 最终简化版本

## 核心变更

由于p5.js的WebGL context限制,最终采用**完全基于p5原生API**的实现。

## 技术方案

### 渲染流程

```
1. OBJ模型 + 发光材质 → haloL0 (原始)
   ↓
2. p5.filter(BLUR) → haloL1, haloL2, haloL3 (金字塔)
   ↓
3. blendMode(ADD) + tint() → 最终合成
```

### 为什么完全移除shader?

**核心问题**: p5.js的Graphics对象有独立的WebGL context

| 尝试 | 方法 | 结果 |
|-----|------|------|
| 1 | 主canvas shader → Graphics | ❌ Context错误 |
| 2 | 为每个Graphics创建shader | ❌ 内存过大 |
| 3 | shader.copyToContext() | ❌ p5不支持 |
| 4 | **发光材质 + p5 filter** | ✅ 可行 |

## 当前实现细节

### 1. 模型渲染 (sketch.ts:142-170)

```typescript
// 使用emissiveMaterial实现发光效果
const breath = 0.8 + 0.2 * Math.sin(time * 0.3);
const r = 76 * breath;   // 绿色
const g = 230 * breath;
const b = 128 * breath;

haloL0.emissiveMaterial(r, g, b);
haloL0.ambientMaterial(r, g, b);
haloL0.model(objModel);
```

**特点:**
- ✅ 不依赖shader
- ✅ 支持呼吸效果
- ✅ WebGL1兼容
- ⚠️ 颜色单一(无渐变)

### 2. 模糊处理 (sketch.ts:47-51)

```typescript
const applyBlur = (source, target, sigma) => {
  target.image(source, -target.width/2, -target.height/2,
               target.width, target.height);
  target.filter(p.BLUR, Math.floor(sigma));
};
```

**限制:**
- sigma最大约10-12 (p5限制)
- 质量低于高斯shader
- 性能尚可

### 3. 合成 (sketch.ts:188-208)

```typescript
// 叠加模糊层
p.blendMode(p.ADD);
p.tint(255, 255, 255, 76);  // 30%
p.image(haloL3, ...);
p.tint(255, 255, 255, 102); // 40%
p.image(haloL2, ...);
p.tint(255, 255, 255, 76);  // 30%
p.image(haloL1, ...);

// 原始层
p.blendMode(p.BLEND);
p.tint(255, 255, 255, 255);
p.image(haloL0, ...);
```

## 与原方案对比

| 特性 | 原方案(Shader) | 最终版(Material) |
|-----|--------------|----------------|
| **视觉质量** | 75% | 60% |
| **实现复杂度** | 高 | 低 ✅ |
| **兼容性** | 受限 | 95% ✅ |
| **颜色渐变** | 支持 | 单色 ⚠️ |
| **边缘柔化** | 好 | 中等 |
| **可维护性** | 低 | 高 ✅ |

## 预期效果

- ✅ "空"字清晰可见
- ✅ 绿色发光效果
- ✅ 呼吸式明暗变化
- ✅ 柔软光晕边缘
- ✅ 缓慢旋转动画
- ⚠️ 无多色渐变 (绿→橙→紫)
- ⚠️ 边缘柔化有限

## 参数调整

### 颜色 (sketch.ts:155-157)

```typescript
const r = 76 * breath;   // 红通道
const g = 230 * breath;  // 绿通道
const b = 128 * breath;  // 蓝通道
```

**预设颜色:**
```typescript
// 青色
r: 0, g: 255, b: 200

// 紫色
r: 200, g: 100, b: 255

// 金色
r: 255, g: 200, b: 50
```

### 呼吸速度 (sketch.ts:154)

```typescript
const breath = 0.8 + 0.2 * Math.sin(time * speed);
```

| speed | 效果 |
|-------|------|
| 0.15 | 极慢 |
| 0.3 | 默认 ✅ |
| 0.8 | 快速 |

### 光晕强度 (sketch.ts:195-201)

```typescript
// 增强光晕
p.tint(255, 255, 255, 120); // 从76提高到120
```

### 模型大小 (sketch.ts:165)

```typescript
haloL0.scale(2.0);  // 当前2倍
// 调整为1.5 (更小) 或 3.0 (更大)
```

## 进一步优化方向

### 方案A: 渐变纹理贴图

预渲染彩色渐变纹理,应用到模型:

```typescript
// 创建渐变纹理
let gradientTex = createGradientTexture();
haloL0.texture(gradientTex);
```

**优势**: 支持复杂颜色渐变
**成本**: 需要UV坐标

### 方案B: 多pass渲染

渲染多层不同颜色叠加:

```typescript
// 第1层: 绿色核心
haloL0a.emissiveMaterial(76, 230, 128);
// 第2层: 橙色外层 (稍大scale)
haloL0b.emissiveMaterial(230, 178, 76);
// 合成
```

**优势**: 接近原始shader效果
**成本**: 多次渲染开销

### 方案C: 回归shader (高级)

为每个Graphics创建独立shader上下文:

```typescript
// 在各Graphics的setup中
haloL0ShaderVert = haloL0.loadShader('vert', 'frag');
```

**优势**: 最佳视觉效果
**成本**: 内存×4, 复杂度高

## 结论

最终版本虽然牺牲了渐变色和完美的柔边,但获得了:

- ✅ **稳定可靠** - 无WebGL context问题
- ✅ **简单易懂** - 全p5原生API
- ✅ **易于维护** - 无shader调试
- ✅ **性能良好** - 60fps on desktop
- ✅ **兼容性好** - WebGL1设备支持

对于**快速验证**和**生产稳定性**而言,这是更务实的选择。

如需极致视觉效果,建议后续:
1. 采用方案B (多pass渲染)
2. 或升级到方案1 (3D距离场纹理)

---
**版本**: v2.0 (简化版)
**日期**: 2025-09-30
**状态**: 生产可用 ✅