# GPT 体积实现路径

本文总结已有实验与 GPT 推荐方案，评估可行性，并提出落地流程。

## 1. 方案回顾与实验状态

| 路线 | 核心思路 | 实验状态 | 效果还原度 | 实现复杂度 | 性能风险 | 兼容性 | 结论 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| **A. 伪体积层叠 (Shell / Sprite Stacking)** | 多层复制模型外壳/贴片，叠噪声透明材质 | ✅ 已尝试：多层 mesh + shader 噪声。出现明显条纹，边缘依旧硬。 | ★★☆☆☆ | ★★☆☆☆ | ★★☆☆☆ | ★★★★★ | 可作占位或降级，无法达成体积雾感。 |
| **B. 屏幕空间后期** | Bloom、Blur、Film Grain、Depth Fog | ✅ 已尝试：多级 Bloom + Grain + Depth Fog。仅产生光晕，缺乏体积深度。 | ★☆☆☆☆ | ★★★☆☆ | ★☆☆☆☆ | ★★★★★ | 只能补氛围，主体仍是硬模型。 |
| **C. 粒子/点云包裹** | 贴面粒子 + 体积粒子，Alpha 混合 | ✅ 已尝试：表面粒子 + ambient glow 粒子。像雪花，主体仍硬朗。 | ★★☆☆☆ | ★★★☆☆ | ★★★☆☆ | ★★★★★ | 颗粒可保留为辅效果，不能解决主体质感。 |
| **D. 多层体积壳 (Triplanar Shell)** | 4 层放大模型，triplanar 噪声 | ✅ 已尝试：4 层 shell，仍有条纹、层次感过强。 | ★★☆☆☆ | ★★★☆☆ | ★★☆☆☆ | ★★★★★ | 证明“层叠路线”难以消除条纹，需换策略。 |
| **E. Raymarch + 程序噪声** | 在包围盒内步进采样噪声/SDF | ⏳ 未实现：需 SDF 或 BVH 支撑，开发周期长。 | ★★★★☆ (理论) | ★★★★☆ | ★★★★☆ | ★★★☆☆ | 中长期目标，可作为高阶版本。 |
| **F. 预烘焙体积贴图** | DCC 烘焙雾体 → 切片/3D 纹理 → 前端采样 | 🚀 推荐主线：待实施。 | ★★★★★ | ★★★☆☆ | ★★★☆☆ | ★★★★☆ (WebGL2 优先，atlas 兼容) | 推荐路径：桌面 Data3DTexture，高性能；移动端 atlas 降级。 |

> 小结：已经验证过的 A~D 路线都无法复刻参考图的“体积弥散噪点”质感；因此第三部分提出的“空间体积贴图实践”是最可行且可控的方向。

## 2. 推荐实现路径（空间体积贴图）

### 2.1 总体策略

1. **内容制作（Blender/Houdini）**
   - 将锚字几何转成体积（Volume/Fog Volume），叠加多尺度噪声。
   - 保持紧凑包围盒，减少空体素。

2. **离线导出**
   - 主路：沿某轴渲染 N 张密度切片（灰度 PNG，128² 或 256²），
     输出时可按 gamma/contrast 做压缩，确保层次集中在 0.1–0.9。
   - 产出 meta.json（切片数量、行列、真实尺寸、颜色 ramp、采样 gamma）。
   - 备选：导出 OpenVDB → 转换成 Uint8 Data3DTexture（WebGL2 路径）。

3. **前端加载**
   - **高质路径 (WebGL2)**：`THREE.Data3DTexture` + `sampler3D`，开启三线性插值。
   - **兼容路径 (WebGL1/移动端)**：切片图集 atlas，shader 手动做三线性插值
     （对相邻切片/像素 interpolate），并支持随机抖动采样。

4. **体积渲染 shader**
   - 在体积包围盒内 raymarch 固定步数（桌面 32~48，移动 16~24）。
   - 每步采样密度，按照颜色 ramp 输出自发光 + 衰减。
   - 使用前向合成 + 早停；对步进长度加入细微随机抖动（蓝噪声/TAA）防 banding。

5. **后期合成**
   - Bloom（Dual-Kawase）、Vignette、薄 Film Grain。
   - 可根据滚动/音频调节体积密度、发光强度，实现“呼吸”。

6. **降级策略**
   - 中低端移动：使用外壳 + Bloom 方案作为 fallback。
   - 更低阶：仅保留渐变背景 + 2D 替代图，保证不黑屏。

### 2.2 交付物/管线拆解

| 阶段 | 负责人 | 产出 | 说明 |
| --- | --- | --- | --- |
| 美术 | 中台/视觉 | 体积切片 PNG 序列 + meta.json | 每组锚字一套；若可能提供 OpenVDB 以备后用。 |
| 工具 | 工程 | 切片打包脚本 → 图集/Uint8Array | 自动生成体积数据、Meta、压缩。 |
| 前端 | 动效工程 | 体积采样组件 (WebGL2) + atlas fallback | 统一 API，内部根据设备能力切换。 |
| QA | QA 团队 | 各平台性能与兼容报告 | 桌面 Chrome/Safari、iOS、Android 至少两档机型。 |

### 2.3 参考配置

- 体素分辨率：桌面 128³，移动端 96³。
- 步数：桌面 40、移动 20，支持步数动态调整。
- 图集大小：例如 128 张 × 128² → 16×8 拼图（2048×1024 PNG ≈ 1–3 MB）。
- 体积 pass 预算：桌面 6–8 ms，移动 10–12 ms 以内。

## 3. 已有实验与经验教训

- **NeonModel3D 组件**：搭建了参数面板、错误捕获、音频联动等基础设施，可直接复用。
- **Shell / 粒子 实验**：证明依赖 mesh 的方案无法消除“贴皮肤”感；截图与参数可作为美术沟通佐证。
- **Ambient Glow / Bloom**：可保留作为后期辅料，但不能承担主体视觉。
- **性能观察**：多层 mesh + 粒子在桌面可跑，移动端压力大；为后续做降级策略提供依据。

## 4. 下一步建议

1. **Proof of Concept**
   - 选一个锚字，在 Blender 制作体积切片。 
   - WebGL2 Demo：实现 Data3DTexture + 简易 raymarch，验证画质与步数。
   - WebGL1 fallback：实现 atlas 采样，对比画质与帧率。

2. **工具自动化**
   - Blender 导出脚本 → 批量生成切片、体积数据。
   - Node 工具 → 合并图集、生成 meta.json。

3. **前端集成**
   - 封装 `NeonVolume` 组件，按设备能力切换高/低质路径。
   - 参数开放：密度倍率、颜色 ramp、呼吸速率、步长抖动幅度等。

4. **性能验证**
   - 桌面：Chrome/Firefox/Safari。
   - 移动：iOS Safari、安卓 Chrome（高/中端机）。
   - 预设降级逻辑，确保低端设备回退到壳层方案。

5. **持续美术协同**
   - 建立体积素材标准：颜色层、噪声密度、渐变深度。
   - 与滚动/音频联动的表现规则。

---

我们建议优先推进“Blender 体积 → 前端体积采样 → 后期合成”这条主线。现有组件和实验结果可以直接用于新方案的框架搭建及降级逻辑。待完成 PoC 与性能验证后，再逐步切换实际页面的渲染实现。
