# CoScroll ä½“ç§¯æ¸²æŸ“æŠ€æœ¯æ–¹æ¡ˆ

## æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†é˜è¿°å®ç°"è½¯ç³¯è¾¹ç•Œ+å¥¶æ²¹æ¸å˜+ä½“ç§¯é›¾åŒ–"æ•ˆæœçš„æŠ€æœ¯è·¯å¾„ï¼ŒåŸºäºå¯¹ShaderParkæºç çš„æ·±åº¦åˆ†æå’Œç§»åŠ¨ç«¯æ€§èƒ½ä¼˜åŒ–å®è·µã€‚

**ç›®æ ‡æ•ˆæœï¼š** å‚è€ƒ `ref/Shader3` ä¸­çƒä½“çš„æŸ”è½¯è¾¹ç•Œå’Œä½“ç§¯æ„Ÿ
**æŠ€æœ¯æŒ‘æˆ˜ï¼š** åœ¨ç§»åŠ¨ç«¯æµè§ˆå™¨å®ç°é«˜è´¨é‡ä½“ç§¯æ¸²æŸ“ï¼ˆç›®æ ‡ 45-60fpsï¼‰
**æ ¸å¿ƒç­–ç•¥ï¼š** ShaderParkå¼è½»é‡ä½“æ¸²æŸ“ï¼ˆä½æ­¥æ•° + é«˜è´¨é‡å™ªå£° + æ—¶ç©ºæ’å€¼ï¼‰

---

## ä¸€ã€é—®é¢˜è¯Šæ–­

### 1.1 å½“å‰æ–¹æ¡ˆçš„æœ¬è´¨é™åˆ¶

**å¤šå±‚å£³ä½“æ¸²æŸ“ï¼ˆç°æœ‰å®ç°ï¼‰ï¼š**
```
å£³ä½“1 (scale=1.000) â†’ alpha=1.0
å£³ä½“2 (scale=1.012) â†’ alpha=0.85
...
å£³ä½“8 (scale=1.084) â†’ alpha=0.05
â†“ å åŠ æ··åˆ
= "å‡è£…"çš„ä½“ç§¯æ„Ÿ
```

**æ ¹æœ¬é—®é¢˜ï¼š**
- âŒ åªæœ‰8ä¸ªç©ºå¿ƒè¡¨é¢ï¼Œæ²¡æœ‰çœŸæ­£çš„"å†…éƒ¨"
- âŒ ç¼ºå°‘å…‰çº¿æ•£å°„ï¼ˆçœŸå®äº‘é›¾éœ€è¦å…‰åœ¨ä»‹è´¨å†…å¤šæ¬¡æ•£å°„ï¼‰
- âŒ è¾¹ç•Œä¸è¿ç»­ï¼ˆå³ä½¿100å±‚ï¼Œæœ¬è´¨è¿˜æ˜¯ç¦»æ•£è¡¨é¢å åŠ ï¼‰
- âŒ ä»æŸäº›è§’åº¦èƒ½çœ‹åˆ°"åˆ†å±‚æ„Ÿ"
- âŒ æ— æ³•å®ç°å‚è€ƒå›¾çš„"æ°¤æ°²æ¶ˆæ•£"æ•ˆæœ

**æ•ˆæœå¯¹æ¯”ï¼š**
| ç‰¹å¾ | å‚è€ƒå›¾éœ€æ±‚ | å¤šå±‚å£³ä½“ | å®Œæ•´ä½“æ¸²æŸ“ |
|------|-----------|---------|-----------|
| è¾¹ç•ŒæŸ”è½¯åº¦ | æè‡´ | 65% | 95% |
| ä½“ç§¯åšåº¦æ„Ÿ | å¼º | 40% | 95% |
| è‰²å½©è¿ç»­æ€§ | é«˜ | 60% | 90% |
| å¤§èŒƒå›´é›¾åŒ– | éœ€è¦ | 50% | 90% |

---

## äºŒã€ShaderParkæºç æ·±åº¦è§£æ

### 2.1 æ ¸å¿ƒä»£ç å‰–æ

```javascript
// ref/Shader3/sketch1732356/spCode.js

// ğŸ”‘ å…³é”®1: æœ€å¤§è¿­ä»£æ¬¡æ•°åªæœ‰8æ¬¡ï¼
setMaxIterations(8);

// ğŸ”‘ å…³é”®2: åŸºäºè§†çº¿æ–¹å‘çš„FBMå™ªå£°
let s = getRayDirection();  // å±å¹•ç©ºé—´æ–¹å‘
let n = sin(fbm(s+vec3(0, 0, -time*.1))*2)*.5+.75;
n = pow(n, vec3(8));       // 8æ¬¡å¹‚æŸ”åŒ–å™ªå£°
color(n)                   // ç›´æ¥ç”¨å™ªå£°å½“é¢œè‰²

// ğŸ”‘ å…³é”®3: å‡ ä½•å®šä¹‰
shape(() => {
  sphere(scale);
})()

// ğŸ”‘ å…³é”®4: è½¯æ··åˆï¼ˆæ ¸å¿ƒï¼‰
blend(.4)  // ShaderParkçš„smooth union
```

### 2.2 æŠ€æœ¯æ­ç§˜

**éœ‡æƒŠçš„å‘ç°ï¼šè¿™ä¸æ˜¯ä¼ ç»Ÿçš„å®Œæ•´ä½“æ¸²æŸ“ï¼**

#### ShaderParkçš„å®ç°åŸç†

1. **2.5DæŠ€å·§è€Œé3Dä½“æ¸²æŸ“**
   - ä¸æ˜¯åœ¨ä½“ç§¯å†…é€æ­¥ray marching
   - è€Œæ˜¯æ ¹æ®"è§†çº¿æ–¹å‘"ç›´æ¥é‡‡æ ·å™ªå£°
   - `getRayDirection()` æ˜¯å±å¹•ç©ºé—´å‘é‡
   - ç”¨æ–¹å‘å‘é‡åšFBMå™ªå£°é‡‡æ ·

2. **blend(.4) æ˜¯é­”æ³•**
   - ShaderParkå†…ç½®çš„å¹³æ»‘æ··åˆå‡½æ•°
   - ç±»ä¼¼SDFçš„ smooth union/min
   - è¿™æ˜¯è¾¹ç•ŒæŸ”è½¯çš„æ ¸å¿ƒ
   - ç­‰ä»·äºGLSLä¸­çš„ `smoothstep` + `mix`

3. **åªç”¨8æ¬¡è¿­ä»£**
   - `setMaxIterations(8)` è¯æ˜æ­¥æ•°æå°‘
   - ShaderParkå¯èƒ½å†…éƒ¨åšç®€åŒ–ray marching
   - ä½†è¿œä½äºä¼ ç»Ÿä½“æ¸²æŸ“çš„64-128æ­¥
   - æ€§èƒ½å‹å¥½çš„å…³é”®

4. **pow(n, vec3(8))**
   - å¯¹å™ªå£°åš8æ¬¡å¹‚
   - è®©ä¸­å¿ƒäº®ã€è¾¹ç¼˜æš—
   - åˆ¶é€ "ä¸­å¿ƒå®ã€è¾¹ç¼˜è™š"çš„æ•ˆæœ
   - ç±»ä¼¼gammaæ ¡æ­£ä½†æ›´æ¿€è¿›

### 2.3 ä¸ºä»€ä¹ˆShaderParkèƒ½ç”¨å°‘é‡æ­¥æ•°ï¼Ÿ

**æ ¸å¿ƒç­–ç•¥ï¼š**
```
ä½è¿­ä»£æ¬¡æ•° + é«˜è´¨é‡å™ªå£° + æ•°å­¦æŠ€å·§
    â†“
äººçœ¼çœ‹ä¸å‡º"8æ­¥è¿˜æ˜¯64æ­¥"
    â†“
ä½†èƒ½çœ‹å‡ºå™ªå£°è´¨é‡å’Œè¾¹ç•ŒæŸ”è½¯åº¦
```

**æ•°å­¦æœ¬è´¨ï¼š**
- ä¼ ç»Ÿä½“æ¸²æŸ“ï¼šç‰©ç†æ­£ç¡®ï¼Œéœ€è¦é«˜é‡‡æ ·ç‡
- ShaderParkï¼šè‰ºæœ¯å¯¼å‘ï¼Œç”¨å™ªå£°æ©ç›–ç¦»æ•£æ€§
- ç»“æœï¼šè§†è§‰æ•ˆæœç›¸ä¼¼ï¼Œæ€§èƒ½æå‡5-8å€

---

## ä¸‰ã€æŠ€æœ¯æ–¹æ¡ˆå¯¹æ¯”

### 3.1 æ–¹æ¡ˆ1ï¼šThree.js + UnrealBloomPass

**åŸç†ï¼š**
```typescript
å¤šå±‚å£³ä½“æ¸²æŸ“ + å±å¹•ç©ºé—´Bloomåå¤„ç†
```

**å®ç°ï¼š**
```javascript
import { EffectComposer, Bloom } from '@react-three/postprocessing'

<EffectComposer>
  <Bloom
    intensity={2.5}          // å¤§èŒƒå›´æ‰©æ•£
    luminanceThreshold={0.2} // ä½é˜ˆå€¼
    radius={1.2}             // å¤§åŠå¾„æ¨¡ç³Š
  />
</EffectComposer>
```

**ä¼˜åŠ£åˆ†æï¼š**
| ç»´åº¦ | è¯„åˆ† | è¯´æ˜ |
|------|------|------|
| æ•ˆæœè¿˜åŸåº¦ | 70-75% | Bloomæ˜¯"å‡"çš„é›¾åŒ– |
| ç§»åŠ¨ç«¯æ€§èƒ½ | â­â­â­â­â­ | 60fps |
| å¼€å‘å‘¨æœŸ | 0.5å¤© | è¿ç§»åˆ°Three.js + é…ç½® |
| å¯æ‰©å±•æ€§ | â­â­ | æœ¬è´¨è¿˜æ˜¯è¡¨é¢æ¸²æŸ“ |

**é€‚ç”¨åœºæ™¯ï¼š**
- å¿«é€ŸåŸå‹éªŒè¯
- å¯¹æ•ˆæœè¦æ±‚ä¸é«˜
- éœ€è¦ç«‹å³ä¸Šçº¿

---

### 3.2 æ–¹æ¡ˆ2ï¼šSDFå®Œæ•´ä½“æ¸²æŸ“

**åŸç†ï¼š**
```
OBJ â†’ ä½“ç´ åŒ– â†’ 3Dçº¹ç† â†’ 64æ­¥Ray Marching
```

**shaderä¼ªä»£ç ï¼š**
```glsl
for(int i = 0; i < 64; i++) {
  vec3 p = rayOrigin + rayDir * t;
  float density = texture(uVolumeTexture, worldToUVW(p)).r;

  // ç´¯ç§¯é¢œè‰²å’Œé€æ˜åº¦
  vec3 sampleColor = getGradient(density);
  float sampleAlpha = density * stepSize;

  color += sampleColor * sampleAlpha * (1.0 - alpha);
  alpha += sampleAlpha * (1.0 - alpha);

  if(alpha > 0.99) break;
  t += stepSize;
}
```

**ä¼˜åŠ£åˆ†æï¼š**
| ç»´åº¦ | è¯„åˆ† | è¯´æ˜ |
|------|------|------|
| æ•ˆæœè¿˜åŸåº¦ | 90-95% | ç‰©ç†æ­£ç¡®çš„ä½“æ¸²æŸ“ |
| ç§»åŠ¨ç«¯æ€§èƒ½ | â­â­ | 20-30fps (éœ€é™çº§) |
| å¼€å‘å‘¨æœŸ | 3-5å¤© | éœ€è¦é¢„å¤„ç†å·¥å…·é“¾ |
| å¯æ‰©å±•æ€§ | â­â­â­â­â­ | æ”¯æŒå„ç§ä½“ç§¯æ•ˆæœ |

**æŠ€æœ¯ç»†èŠ‚ï¼š**

1. **ä½“ç´ åŒ–æµç¨‹**
   ```bash
   # Pythonå·¥å…·é“¾
   pip install trimesh mesh_to_sdf
   python obj_to_sdf.py 001_ç©º.obj \
     --resolution 128 \
     --output sdf_128.bin
   ```

2. **3Dçº¹ç†åŠ è½½**
   ```javascript
   const volumeData = await fetch('sdf_128.bin')
     .then(r => r.arrayBuffer())
     .then(b => new Uint8Array(b));

   const volumeTexture = new THREE.Data3DTexture(
     volumeData, 128, 128, 128,
     THREE.RedFormat
   );
   volumeTexture.minFilter = THREE.LinearFilter; // æ’å€¼
   ```

3. **æ€§èƒ½ç“¶é¢ˆ**
   ```
   æ¡Œé¢: 64æ­¥ Ã— 1080p = 130M é‡‡æ ·/å¸§  âœ… OK
   ç§»åŠ¨: 64æ­¥ Ã— 720p  = 58M é‡‡æ ·/å¸§   âŒ å¤ªæ…¢
         32æ­¥ Ã— 540p  = 17M é‡‡æ ·/å¸§   âš ï¸ å‹‰å¼º
   ```

**é€‚ç”¨åœºæ™¯ï¼š**
- æ¡Œé¢ç«¯å±•ç¤º
- è§†é¢‘æ¸²æŸ“
- å¯¹æ•ˆæœæœ‰æè‡´è¦æ±‚
- ä¸è€ƒè™‘ç§»åŠ¨ç«¯

---

### 3.3 æ–¹æ¡ˆ3ï¼šShaderParkå¼è½»é‡ä½“æ¸²æŸ“ï¼ˆæ¨èï¼‰

**æ ¸å¿ƒæ€æƒ³ï¼š**
```
ä½æ­¥æ•°(12-16) + æ—¶é—´æŠ–åŠ¨ + ç©ºé—´æ’å€¼ + FBMå™ªå£°
    â†“
è§†è§‰æ•ˆæœæ¥è¿‘å®Œæ•´ä½“æ¸²æŸ“
    â†“
æ€§èƒ½å¼€é”€é™ä½70%
```

**å®Œæ•´shaderå®ç°ï¼š**

```glsl
// ============================================
// ShaderParkå¼è½»é‡ä½“æ¸²æŸ“ Fragment Shader
// ============================================

uniform sampler3D uVolumeTexture;  // 64Â³ä½åˆ†è¾¨ç‡SDF
uniform float uTime;
uniform vec3 uCameraPos;

varying vec3 vWorldPos;
varying vec3 vNormal;

// === FBMå™ªå£°ï¼ˆ3ä¸ªoctaveï¼‰===
float hash(vec3 p) {
  p = vec3(
    dot(p, vec3(127.1, 311.7, 74.7)),
    dot(p, vec3(269.5, 183.3, 246.1)),
    dot(p, vec3(113.5, 271.9, 124.6))
  );
  return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);
}

float noise(vec3 x) {
  vec3 i = floor(x);
  vec3 f = fract(x);
  f = f * f * (3.0 - 2.0 * f);

  float n000 = hash(i + vec3(0,0,0));
  float n100 = hash(i + vec3(1,0,0));
  float n010 = hash(i + vec3(0,1,0));
  float n110 = hash(i + vec3(1,1,0));
  float n001 = hash(i + vec3(0,0,1));
  float n101 = hash(i + vec3(1,0,1));
  float n011 = hash(i + vec3(0,1,1));
  float n111 = hash(i + vec3(1,1,1));

  float nx00 = mix(n000, n100, f.x);
  float nx10 = mix(n010, n110, f.x);
  float nx01 = mix(n001, n101, f.x);
  float nx11 = mix(n011, n111, f.x);
  float nxy0 = mix(nx00, nx10, f.y);
  float nxy1 = mix(nx01, nx11, f.y);

  return mix(nxy0, nxy1, f.z);
}

vec3 fbm(vec3 p, int octaves) {
  vec3 result = vec3(0.0);
  float amplitude = 1.0;
  float frequency = 1.0;

  for(int i = 0; i < 3; i++) {
    if(i >= octaves) break;
    result += vec3(
      noise(p * frequency),
      noise(p * frequency + 0.1),
      noise(p * frequency + 0.2)
    ) * amplitude;
    amplitude *= 0.5;
    frequency *= 2.0;
  }

  return result;
}

// === æ¸å˜è‰²ï¼ˆå‚è€ƒå›¾é…è‰²ï¼‰===
vec3 getGradientColor(float t) {
  vec3 c1 = vec3(0.4, 0.9, 0.7);   // é’ç»¿ä¸­å¿ƒ
  vec3 c2 = vec3(0.6, 0.85, 0.95); // æµ…è“
  vec3 c3 = vec3(0.95, 0.7, 0.85); // ç²‰ç´«è¾¹ç¼˜

  if(t < 0.5) {
    return mix(c1, c2, t * 2.0);
  } else {
    return mix(c2, c3, (t - 0.5) * 2.0);
  }
}

// === ä¸–ç•Œåæ ‡ â†’ ä½“ç´ UV ===
vec3 worldToUVW(vec3 worldPos) {
  // å‡è®¾æ¨¡å‹åœ¨ [-1,1] èŒƒå›´
  return (worldPos + 1.0) * 0.5;
}

void main() {
  vec3 rayOrigin = uCameraPos;
  vec3 rayDir = normalize(vWorldPos - uCameraPos);

  // ğŸ”‘ å…³é”®1: åªç”¨12æ­¥ï¼ˆç§»åŠ¨ç«¯ï¼‰æˆ–16æ­¥ï¼ˆæ¡Œé¢ï¼‰
  const int MAX_STEPS = 12;
  float stepSize = 2.5 / float(MAX_STEPS);

  vec3 accumulatedColor = vec3(0.0);
  float accumulatedAlpha = 0.0;

  // ğŸ”‘ å…³é”®2: æ—¶é—´æŠ–åŠ¨ç§å­
  float jitterSeed = uTime * 0.1 + dot(gl_FragCoord.xy, vec2(12.9898, 78.233));

  for(int i = 0; i < MAX_STEPS; i++) {
    // ğŸ”‘ å…³é”®3: æ¯å¸§éšæœºåç§»é‡‡æ ·ä½ç½®ï¼ˆæ—¶é—´æŠ–åŠ¨ï¼‰
    float jitter = fract(sin(jitterSeed + float(i)) * 43758.5453) * 0.5;
    float t = (float(i) + jitter) * stepSize;

    vec3 samplePos = rayOrigin + rayDir * t;
    vec3 uvw = worldToUVW(samplePos);

    // è¾¹ç•Œæ£€æŸ¥
    if(any(lessThan(uvw, vec3(0.0))) || any(greaterThan(uvw, vec3(1.0)))) {
      continue;
    }

    // ğŸ”‘ å…³é”®4: é‡‡æ ·ä½åˆ†è¾¨ç‡ä½“ç´ ï¼ˆ64Â³ï¼‰+ ç¡¬ä»¶ä¸‰çº¿æ€§æ’å€¼
    float sdfValue = texture(uVolumeTexture, uvw).r;

    // SDFè½¬å¯†åº¦ï¼ˆè·ç¦»è¡¨é¢è¶Šè¿‘å¯†åº¦è¶Šé«˜ï¼‰
    float density = smoothstep(0.1, -0.05, sdfValue);

    // ğŸ”‘ å…³é”®5: FBMå™ªå£°æ³¨å…¥ç»†èŠ‚
    vec3 noisePos = samplePos * 2.0 + vec3(0.0, 0.0, uTime * 0.08);
    vec3 fbmNoise = fbm(noisePos, 3);

    // ShaderParkçš„æŠ€å·§ï¼šsin + pow
    fbmNoise = sin(fbmNoise * 2.0) * 0.5 + 0.75;
    fbmNoise = pow(fbmNoise, vec3(8.0));

    // ç”¨å™ªå£°è°ƒåˆ¶å¯†åº¦ï¼ˆå¢åŠ ç»†èŠ‚ï¼‰
    density *= (0.7 + fbmNoise.x * 0.3);

    // ğŸ”‘ å…³é”®6: åŸºäºå¯†åº¦çš„é¢œè‰²
    vec3 sampleColor = getGradientColor(density) * fbmNoise;
    float sampleAlpha = density * stepSize;

    // å‰å‘ç´¯ç§¯ï¼ˆBeer's Lawï¼‰
    accumulatedColor += sampleColor * sampleAlpha * (1.0 - accumulatedAlpha);
    accumulatedAlpha += sampleAlpha * (1.0 - accumulatedAlpha);

    // æå‰é€€å‡ºä¼˜åŒ–
    if(accumulatedAlpha > 0.95) break;
  }

  gl_FragColor = vec4(accumulatedColor, accumulatedAlpha);
}
```

**ä¼˜åŠ£åˆ†æï¼š**
| ç»´åº¦ | è¯„åˆ† | è¯´æ˜ |
|------|------|------|
| æ•ˆæœè¿˜åŸåº¦ | 85-90% | æ¥è¿‘å®Œæ•´ä½“æ¸²æŸ“ |
| ç§»åŠ¨ç«¯æ€§èƒ½ | â­â­â­â­ | 45-55fps |
| å¼€å‘å‘¨æœŸ | 2-3å¤© | éœ€ä½“ç´ åŒ–+shader |
| å¯æ‰©å±•æ€§ | â­â­â­â­ | å¯å¹³æ»‘å‡çº§ |

---

## å››ã€æ ¸å¿ƒä¼˜åŒ–æŠ€æœ¯è¯¦è§£

### 4.1 æ—¶é—´æŠ–åŠ¨ï¼ˆTemporal Jitteringï¼‰

**åŸç†ï¼š**
```
å¸§A: é‡‡æ ·ä½ç½® [0.0, 0.1, 0.2, 0.3, ...]
å¸§B: é‡‡æ ·ä½ç½® [0.05, 0.15, 0.25, 0.35, ...]  â† åç§»0.05
å¸§C: é‡‡æ ·ä½ç½® [0.03, 0.13, 0.23, 0.33, ...]  â† åç§»0.03
    â†“
å¤šå¸§ç´¯ç§¯ = è¶…é«˜é‡‡æ ·ç‡
```

**å®ç°ï¼š**
```glsl
// æ¯å¸§ä¸åŒçš„éšæœºç§å­
float jitter = hash(gl_FragCoord.xy + uTime);
float t = (float(i) + jitter * 0.5) * stepSize;
```

**æ•ˆæœï¼š**
- å•å¸§å¯èƒ½æœ‰è½»å¾®å™ªç‚¹
- é™æ­¢ç”»é¢ä¼šè‡ªåŠ¨"æ—¶é—´åèµ°æ ·"
- è¿åŠ¨æ—¶å™ªç‚¹ä¸æ˜æ˜¾ï¼ˆäººçœ¼è¿½è¸ªè¿åŠ¨ï¼‰

**æ€§èƒ½æå‡ï¼š**
```
æ— æŠ–åŠ¨: 64æ­¥æ‰èƒ½å¹³æ»‘
æœ‰æŠ–åŠ¨: 12æ­¥ Ã— 5å¸§ = ç­‰æ•ˆ60æ­¥
æ€§èƒ½æå‡: 5.3å€
```

---

### 4.2 ç©ºé—´æ’å€¼ï¼ˆTrilinear Filteringï¼‰

**åŸç†ï¼š**
```
64Â³ä½“ç´  + ç¡¬ä»¶æ’å€¼ â‰ˆ 128Â³~192Â³è§†è§‰æ•ˆæœ
```

**Three.jsé…ç½®ï¼š**
```javascript
volumeTexture.minFilter = THREE.LinearFilter;
volumeTexture.magFilter = THREE.LinearFilter;
// GPUè‡ªåŠ¨åš8ç‚¹æ’å€¼
```

**å†…å­˜å¯¹æ¯”ï¼š**
```
64Â³  Ã— 1byte = 262KB   âœ… å¿«
128Â³ Ã— 1byte = 2MB     âš ï¸ ä¸­ç­‰
256Â³ Ã— 1byte = 16MB    âŒ ç§»åŠ¨ç«¯å±é™©
```

**æ€§èƒ½æå‡ï¼š**
- å†…å­˜é™ä½ 8-64å€
- é‡‡æ ·é€Ÿåº¦æ›´å¿«ï¼ˆcacheå‹å¥½ï¼‰
- è§†è§‰å·®å¼‚å°äº10%

---

### 4.3 FBMå™ªå£°ç»†èŠ‚æ³¨å…¥

**åŸç†ï¼š**
```
ä½åˆ†è¾¨ç‡ä½“ç´  + é«˜é¢‘å™ªå£° = é«˜ç»†èŠ‚è§†è§‰
```

**å®ç°ï¼š**
```glsl
// 3ä¸ªoctaveçš„FBM
vec3 detail = fbm(samplePos * 4.0, 3);

// è°ƒåˆ¶å¯†åº¦
density *= (0.7 + detail.x * 0.3);

// ShaderParkæŠ€å·§ï¼š8æ¬¡å¹‚å¼ºåŒ–å¯¹æ¯”
detail = pow(detail, vec3(8.0));
```

**ä¸ºä»€ä¹ˆæœ‰æ•ˆï¼š**
- äººçœ¼å¯¹é«˜é¢‘ç»†èŠ‚æ•æ„Ÿ
- ä½é¢‘å½¢çŠ¶å¯ä»¥ä½åˆ†è¾¨ç‡
- å™ªå£°æ˜¯å»‰ä»·çš„ï¼ˆçº¯æ•°å­¦ï¼Œæ— çº¹ç†é‡‡æ ·ï¼‰

**æ€§èƒ½ï¼š**
- FBM 3ä¸ªoctave â‰ˆ 9æ¬¡ `sin()` è°ƒç”¨
- æ¯”ä¸€æ¬¡3Dçº¹ç†é‡‡æ ·å¿«

---

### 4.4 è‡ªé€‚åº”æ­¥æ•°

**åŸç†ï¼š**
```
è¾¹ç¼˜åŒºåŸŸï¼š16æ­¥ï¼ˆéœ€è¦ç»†èŠ‚ï¼‰
å†…éƒ¨å®å¿ƒï¼š4æ­¥ï¼ˆåæ­£ä¸é€æ˜ï¼‰
ç©ºç™½åŒºåŸŸï¼šè·³è¿‡
```

**å®ç°ï¼š**
```glsl
// æ ¹æ®SDFå€¼åˆ¤æ–­
float sdf = texture(uVolume, uvw).r;

if(sdf > 0.2) {
  // è¿œç¦»è¡¨é¢ï¼Œå¤§æ­¥å‰è¿›
  t += stepSize * 4.0;
} else {
  // æ¥è¿‘è¡¨é¢ï¼Œå°æ­¥ç²¾ç»†
  t += stepSize;
}
```

**æ€§èƒ½æå‡ï¼š**
- å¹³å‡æ­¥æ•°ä»12é™åˆ°8
- å¯¹è§†è§‰å‡ ä¹æ— å½±å“

---

## äº”ã€å·¥ç¨‹åŒ–å¿…åšä¼˜åŒ–ï¼ˆä¸“å®¶å®¡é˜…ï¼‰

> **å®¡é˜…ç»“è®ºï¼š** ä½œä¸ºç§»åŠ¨ç«¯è‰ºæœ¯demoï¼Œè¿™å¥—æŠ€æœ¯æ ˆï¼ˆ64Â³/48Â³ä½åˆ†ä½“ç§¯ + 12â€“16æ­¥å°„çº¿è¡Œè¿› + æ—¶é—´æŠ–åŠ¨ + ä¸‰çº¿æ€§æ’å€¼ + LUTä¸Šè‰²ï¼‰æ˜¯å½“å‰æ€§ä»·æ¯”æœ€é«˜çš„è·¯çº¿ã€‚ä»¥ä¸‹8ä¸ªä¼˜åŒ–æ˜¯ç¨³å®šæ€§ä¸æ•ˆæœçš„å…³é”®ã€‚

### 5.1 æ ¸å¿ƒä¼˜åŒ–æ¸…å•ï¼ˆæŒ‰ä¼˜å…ˆçº§ï¼‰

#### â­â­â­ P0çº§ï¼šMVPå¿…éœ€ï¼ˆä¸åšä¼šæœ‰æ˜æ˜¾é—®é¢˜ï¼‰

##### 1. æ˜ç¡®SDFå­˜å‚¨ä¸å¯†åº¦æ˜ å°„è§„èŒƒ

**é—®é¢˜ï¼š** åŸæ–¹æ¡ˆ `smoothstep(0.1, -0.05, sdfValue)` é˜ˆå€¼ä¸ç»Ÿä¸€ï¼Œå®¹æ˜“éšåˆ†è¾¨ç‡æ”¹å˜è€Œé”™ä½ã€‚

**æ ‡å‡†åŒ–è§„èŒƒï¼š**
```glsl
// å­˜ç›˜æ—¶ï¼ˆPythoné¢„å¤„ç†ï¼‰
// SDF âˆˆ [-1, 1] â†’ R8
stored_value = (sdf * 0.5 + 0.5) * 255.0

// shaderä¸­è¿˜åŸ
float sdf = texture(uVolumeTexture, uvw).r * 2.0 - 1.0;  // è¿˜åŸåˆ°[-1,1]

// å¯†åº¦è®¡ç®—ï¼ˆwæ§åˆ¶è½¯è¾¹å®½åº¦ï¼Œå•ä½ï¼šä½“ç´ ï¼‰
float w = 1.2;  // è½¯è¾¹å®½åº¦
float density = 1.0 - smoothstep(-w / volumeResolution,
                                  +w / volumeResolution,
                                  sdf);
```

**æ”¶ç›Šï¼š**
- âœ… ä¸åŒåˆ†è¾¨ç‡ä½“ç´ ç»“æœä¸€è‡´
- âœ… wå‚æ•°ç‰©ç†æ„ä¹‰æ˜ç¡®ï¼ˆä½“ç´ æ•°ï¼‰
- âœ… é¿å…é˜ˆå€¼ç›¸äº’å†²çª

---

##### 2. AABBåŒ…å›´ç›’ç›¸äº¤è£å‰ª

**é—®é¢˜ï¼š** å…‰çº¿åœ¨ä½“ç§¯å¤–ç©ºèµ°æµªè´¹æ€§èƒ½ï¼Œä¸”æ— æ³•æ­£ç¡®å¤„ç†ä¸åœºæ™¯çš„æ·±åº¦é®æŒ¡ã€‚

**å®ç°ï¼š**
```glsl
bool intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax,
                   out float tEnter, out float tExit) {
  vec3 invDir = 1.0 / rayDir;
  vec3 t0 = (boxMin - rayOrigin) * invDir;
  vec3 t1 = (boxMax - rayOrigin) * invDir;

  vec3 tMin = min(t0, t1);
  vec3 tMax = max(t0, t1);

  tEnter = max(max(tMin.x, tMin.y), tMin.z);
  tExit = min(min(tMax.x, tMax.y), tMax.z);

  return tExit > max(0.0, tEnter);
}

void main() {
  float tEnter, tExit;
  if (!intersectAABB(rayOrigin, rayDir, vec3(-1.0), vec3(1.0), tEnter, tExit)) {
    discard;  // å…‰çº¿æœªå‘½ä¸­ä½“ç§¯
  }

  // ä¸åœºæ™¯æ·±åº¦åšé®æŒ¡è£å‰ª
  float sceneDepth = getSceneDepth(gl_FragCoord.xy);
  tExit = min(tExit, sceneDepth);

  // ä»tEnterå¼€å§‹ray march
  float t = max(0.0, tEnter);
  for(int i = 0; i < MAX_STEPS && t < tExit; i++) {
    // ...
  }
}
```

**æ”¶ç›Šï¼š**
- âœ… æ€§èƒ½æå‡20-30%ï¼ˆè·³è¿‡ç©ºåŒºåŸŸï¼‰
- âœ… æ­£ç¡®å¤„ç†ä¸åœºæ™¯çš„æ·±åº¦å…³ç³»
- âœ… é¿å…è¾¹ç•Œè¶Šç•Œé‡‡æ ·

---

##### 3. SDFè‡ªé€‚åº”æ­¥é•¿ï¼ˆSphere Tracingè½»é‡ç‰ˆï¼‰

**åŸç†ï¼š** è¿œç¦»è¡¨é¢æ—¶å¤§æ­¥å‰è¿›ï¼Œæ¥è¿‘è¡¨é¢æ—¶å°æ­¥ç²¾ç»†é‡‡æ ·ã€‚

**å®ç°ï¼š**
```glsl
uniform float uStepFar;    // 0.012 * bboxSize  è¿œç¦»è¡¨é¢æ­¥é•¿
uniform float uStepScale;  // 0.25 * bboxSize   SDFç¼©æ”¾ç³»æ•°
uniform float uStepNear;   // 0.004 * bboxSize  è¿‘è¡¨é¢æ­¥é•¿
uniform float uBand;       // 1.5 / volumeRes   è¡¨é¢é™„è¿‘é˜ˆå€¼

float t = tEnter;
for(int i = 0; i < MAX_STEPS && t < tExit; i++) {
  vec3 p = rayOrigin + rayDir * t;
  float sdf = sampleSDF(worldToUVW(p));

  // è‡ªé€‚åº”æ­¥é•¿
  float step;
  if(abs(sdf) > uBand) {
    // è¿œç¦»è¡¨é¢ï¼šå¤§æ­¥å‰è¿›ï¼ˆsphere tracingï¼‰
    step = max(uStepFar, abs(sdf) * uStepScale);
  } else {
    // è¿‘è¡¨é¢ï¼šå°æ­¥ç²¾ç»†
    step = uStepNear;

    // å¯é€‰ï¼šäºŒåˆ†refinementï¼ˆ1-2æ¬¡ï¼‰
    // t = binaryRefine(t, step, rayDir);
  }

  // å¯†åº¦ç´¯ç§¯...

  t += step;
}
```

**æ”¶ç›Šï¼š**
- âœ… å¹³å‡æ­¥æ•°ä»12é™åˆ°7-9ï¼ˆæ€§èƒ½æå‡30-40%ï¼‰
- âœ… è¾¹ç•Œè´¨é‡æ›´å¥½ï¼ˆè¿‘è¡¨é¢å¯†é›†é‡‡æ ·ï¼‰
- âœ… ä¸å¢åŠ å¯è§å™ªç‚¹

---

#### â­â­ P1çº§ï¼šæ˜¾è‘—æå‡æ•ˆæœï¼ˆå¼ºçƒˆæ¨èï¼‰

##### 4. ä½é€¸æ•£åºåˆ—æŠ–åŠ¨ï¼ˆæ›¿ä»£éšæœºï¼‰

**é—®é¢˜ï¼š** å®Œå…¨éšæœºæŠ–åŠ¨ä¼šäº§ç”Ÿèšå›¢ï¼ˆclumpingï¼‰ï¼ŒæŸäº›åŒºåŸŸè¿‡é‡‡æ ·ï¼ŒæŸäº›åŒºåŸŸæ¬ é‡‡æ ·ã€‚

**æ”¹è¿›ï¼š**
```glsl
// ä½¿ç”¨Haltonåºåˆ—æˆ–BayerçŸ©é˜µ
const float bayer4x4[16] = float[](
  0.0/16.0,  8.0/16.0,  2.0/16.0, 10.0/16.0,
  12.0/16.0, 4.0/16.0, 14.0/16.0,  6.0/16.0,
  3.0/16.0, 11.0/16.0,  1.0/16.0,  9.0/16.0,
  15.0/16.0, 7.0/16.0, 13.0/16.0,  5.0/16.0
);

float getBayerJitter(vec2 screenPos, int frameIndex) {
  ivec2 pixel = ivec2(screenPos) % 4;
  int index = pixel.y * 4 + pixel.x;
  float bayer = bayer4x4[index];

  // æ··å…¥æ—¶é—´åç§»
  float temporal = fract(float(frameIndex) * 0.618034);  // é»„é‡‘æ¯”

  return fract(bayer + temporal);
}

// åœ¨ray marchä¸­ä½¿ç”¨
float jitter = getBayerJitter(gl_FragCoord.xy, uFrameIndex);
float t = tEnter + jitter * stepSize;
```

**æ”¶ç›Šï¼š**
- âœ… æ›´å‡åŒ€çš„ç©ºé—´è¦†ç›–
- âœ… é…åˆTAAæŠ—é”¯é½¿æ•ˆæœæ›´å¥½
- âœ… è¿åŠ¨æ—¶é¢—ç²’æ›´æœå¸–

---

##### 5. è½»é‡TAAï¼ˆå†å²å¸§å¤¹å–ï¼‰

**æ ¸å¿ƒï¼š** æ··åˆå†å²å¸§é¢œè‰²ï¼Œä½†ç”¨é‚»åŸŸå¤¹å–ï¼ˆneighborhood clampingï¼‰é˜²æ­¢æ‹–å½±ã€‚

**å®ç°ï¼š**
```glsl
// Fragment Shader
uniform sampler2D uHistoryColor;   // ä¸Šä¸€å¸§é¢œè‰²
uniform sampler2D uMotionVector;   // å¯é€‰ï¼šè¿åŠ¨çŸ¢é‡
uniform float uTaaAlpha;           // 0.6-0.8

vec3 currentColor = computeVolumeColor(...);

// 1. é‡‡æ ·å†å²é¢œè‰²ï¼ˆç®€å•ç‰ˆï¼šç›´æ¥ç”¨å½“å‰UVï¼‰
vec2 historyUV = gl_FragCoord.xy / uResolution;
vec3 historyColor = texture(uHistoryColor, historyUV).rgb;

// 2. é‚»åŸŸå¤¹å–ï¼ˆ3Ã—3ï¼‰
vec3 colorMin = vec3(1e10);
vec3 colorMax = vec3(-1e10);
for(int y = -1; y <= 1; y++) {
  for(int x = -1; x <= 1; x++) {
    vec2 offset = vec2(x, y) / uResolution;
    vec3 neighbor = texture(uCurrentColor, historyUV + offset).rgb;
    colorMin = min(colorMin, neighbor);
    colorMax = max(colorMax, neighbor);
  }
}

// å¤¹å–å†å²é¢œè‰²åˆ°é‚»åŸŸèŒƒå›´
historyColor = clamp(historyColor, colorMin, colorMax);

// 3. æŒ‡æ•°ç§»åŠ¨å¹³å‡
vec3 finalColor = mix(currentColor, historyColor, uTaaAlpha);

gl_FragColor = vec4(finalColor, alpha);
```

**æ”¶ç›Šï¼š**
- âœ… æ˜æ˜¾æŠ‘åˆ¶æ—¶é—´æŠ–åŠ¨äº§ç”Ÿçš„å™ªç‚¹
- âœ… é™æ­¢æ—¶ç”»é¢æ›´å¹³æ»‘
- âœ… è¿åŠ¨æ—¶æ— æ˜æ˜¾æ‹–å½±

---

##### 6. æŒ‰éœ€æ³•çº¿ä¼°è®¡

**é—®é¢˜ï¼š** æ¯ä¸ªé‡‡æ ·ç‚¹éƒ½è®¡ç®—æ³•çº¿ä¼šå¤š6æ¬¡çº¹ç†é‡‡æ ·ï¼ˆÂ±X/Y/Zï¼‰ï¼Œå¤§éƒ¨åˆ†ç‚¹ç”¨ä¸åˆ°ã€‚

**ä¼˜åŒ–ï¼š**
```glsl
float t = tEnter;
for(int i = 0; i < MAX_STEPS && t < tExit; i++) {
  vec3 p = rayOrigin + rayDir * t;
  vec3 uvw = worldToUVW(p);
  float sdf = texture(uVolumeTexture, uvw).r * 2.0 - 1.0;

  float density = 1.0 - smoothstep(-uW, uW, sdf);

  // åªåœ¨å¯†åº¦è¶³å¤Ÿé«˜ï¼ˆæ¥è¿‘è¡¨é¢ï¼‰æ—¶è®¡ç®—æ³•çº¿
  if(density > 0.1 && abs(sdf) < uBand) {
    vec3 eps = vec3(1.0 / uVolumeResolution, 0.0, 0.0);
    vec3 normal = normalize(vec3(
      texture(uVolumeTexture, uvw + eps.xyy).r - texture(uVolumeTexture, uvw - eps.xyy).r,
      texture(uVolumeTexture, uvw + eps.yxy).r - texture(uVolumeTexture, uvw - eps.yxy).r,
      texture(uVolumeTexture, uvw + eps.yyx).r - texture(uVolumeTexture, uvw - eps.yyx).r
    ));

    // ä½¿ç”¨æ³•çº¿åšå…‰ç…§
    vec3 color = shadeWithNormal(normal, rayDir, density);
    // ...
  } else {
    // ä½“ç§¯å†…éƒ¨/è¿œå¤„ï¼šåªç”¨LUTç›´æ¥ä¸Šè‰²
    vec3 color = getGradientColor(density);
    // ...
  }

  t += step;
}
```

**æ”¶ç›Šï¼š**
- âœ… å‡å°‘70-80%çš„é¢å¤–çº¹ç†é‡‡æ ·
- âœ… æ€§èƒ½æå‡15-25%
- âœ… å¯¹è§†è§‰æ•ˆæœæ— è´Ÿé¢å½±å“

---

#### â­ P2çº§ï¼šå…¼å®¹æ€§ä¸å…œåº•ï¼ˆç”Ÿäº§ç¯å¢ƒå¿…éœ€ï¼‰

##### 7. 3Dçº¹ç†å›é€€åˆ°2Då›¾é›†

**åŸå› ï¼š** WebGL2çš„TEXTURE_3Dåœ¨ç§»åŠ¨ç«¯æ”¯æŒè‰¯å¥½ï¼Œä½†ä»æœ‰å°‘é‡è®¾å¤‡ä¸æ”¯æŒæˆ–æœ‰bugã€‚

**å®ç°ï¼š**
```javascript
// é¢„å¤„ç†ï¼šå°†64Â³ä½“ç´ æ’æˆ8Ã—8çš„2Då›¾é›†
// æ¯ä¸ªåˆ‡ç‰‡64Ã—64ï¼Œæ€»å›¾512Ã—512

// Pythonè„šæœ¬
import numpy as np
from PIL import Image

sdf_volume = np.fromfile('sdf_64.bin', dtype=np.uint8).reshape(64, 64, 64)

# æ’åˆ—æˆ8Ã—8å›¾é›†
atlas = np.zeros((512, 512), dtype=np.uint8)
for z in range(64):
  row = z // 8
  col = z % 8
  atlas[row*64:(row+1)*64, col*64:(col+1)*64] = sdf_volume[:, :, z]

Image.fromarray(atlas).save('sdf_64_atlas.png')
```

```glsl
// Shaderä¸­æ‰‹åŠ¨å¯»å€
uniform sampler2D uVolumeAtlas;  // 512Ã—512å›¾é›†
uniform float uSlices;           // 64å±‚
uniform float uSliceSize;        // 64px

float sampleSDFAtlas(vec3 uvw) {
  // è®¡ç®—Zå±‚ç´¢å¼•
  float zSlice = uvw.z * (uSlices - 1.0);
  float z0 = floor(zSlice);
  float z1 = min(z0 + 1.0, uSlices - 1.0);
  float zFrac = fract(zSlice);

  // è®¡ç®—å›¾é›†UV
  vec2 atlasUV0 = vec2(
    (mod(z0, 8.0) + uvw.x) / 8.0,
    (floor(z0 / 8.0) + uvw.y) / 8.0
  );
  vec2 atlasUV1 = vec2(
    (mod(z1, 8.0) + uvw.x) / 8.0,
    (floor(z1 / 8.0) + uvw.y) / 8.0
  );

  // æ‰‹åŠ¨ä¸‰çº¿æ€§æ’å€¼ï¼ˆZæ–¹å‘ï¼‰
  float sample0 = texture(uVolumeAtlas, atlasUV0).r;
  float sample1 = texture(uVolumeAtlas, atlasUV1).r;

  return mix(sample0, sample1, zFrac);
}
```

**æ”¶ç›Šï¼š**
- âœ… å…¼å®¹æ‰€æœ‰WebGL2è®¾å¤‡
- âœ… å¯æ§æ€§æ›´å¼ºï¼ˆçº¹ç†å‹ç¼©ã€mipmapï¼‰
- âœ… è°ƒè¯•æ›´æ–¹ä¾¿ï¼ˆå¯ç›´æ¥æŸ¥çœ‹å›¾é›†ï¼‰

---

##### 8. ç§»åŠ¨ç«¯åŠ¨æ€é™çº§ç­–ç•¥

**å®ç°ï¼š**
```javascript
// è®¾å¤‡æ£€æµ‹
const isMobile = /Android|iPhone|iPad/i.test(navigator.userAgent);
const gpu = renderer.capabilities.maxTextureSize;

// æ€§èƒ½ç›‘æ§
let fps = 60;
setInterval(() => {
  fps = stats.getFPS();
}, 1000);

// åŠ¨æ€è°ƒæ•´ç­–ç•¥
function updateQuality() {
  if (fps < 40) {
    // é™çº§1ï¼šå‡å°‘æ­¥æ•°
    volumeMaterial.defines.MAX_STEPS = Math.max(8, MAX_STEPS - 2);

    // é™çº§2ï¼šé™ä½æ¸²æŸ“åˆ†è¾¨ç‡
    renderTarget.setSize(width * 0.75, height * 0.75);

    // é™çº§3ï¼šç¦ç”¨æ³•çº¿è®¡ç®—
    volumeMaterial.defines.USE_NORMALS = false;

    console.warn('æ€§èƒ½ä¸è¶³ï¼Œè‡ªåŠ¨é™çº§');
  } else if (fps > 55 && renderTarget.width < width) {
    // æ¢å¤ï¼šæ€§èƒ½å……è¶³æ—¶æ¢å¤è´¨é‡
    renderTarget.setSize(width, height);
  }
}
```

**æŒ¡æ¿é…ç½®ï¼š**
```javascript
const qualityPresets = {
  high: {
    steps: 16,
    volumeRes: 64,
    renderScale: 1.0,
    useNormals: true,
    useTAA: true
  },
  medium: {
    steps: 12,
    volumeRes: 48,
    renderScale: 0.85,
    useNormals: true,
    useTAA: true
  },
  low: {
    steps: 8,
    volumeRes: 48,
    renderScale: 0.75,
    useNormals: false,
    useTAA: false
  },
  potato: {
    steps: 6,
    volumeRes: 32,
    renderScale: 0.6,
    useNormals: false,
    useTAA: false
  }
};

// è‡ªåŠ¨é€‰æ‹©
let preset = isMobile ? 'medium' : 'high';
if (gpu < 4096) preset = 'low';
applyQualityPreset(qualityPresets[preset]);
```

---

### 5.2 å¯é€‰è¿›é˜¶ä¼˜åŒ–ï¼ˆç”»è´¨è¿›ä¸€æ­¥æå‡ï¼‰

#### ç¨€ç–å æ®æ©ç ï¼ˆç©ºåŸŸåŠ é€Ÿè¿›é˜¶ï¼‰

**åŸç†ï¼š** é¢„è®¡ç®—8Â³æˆ–16Â³çš„ä½åˆ†è¾¨ç‡å æ®ç½‘æ ¼ï¼Œç©ºç“¦ç‰‡ç›´æ¥è·³è¿‡ã€‚

```glsl
uniform sampler2D uOccupancyMap;  // 16Ã—16çš„2Då›¾é›†ï¼Œæ¯åƒç´ ä»£è¡¨ä¸€ä¸ªå—

bool isBlockOccupied(vec3 uvw) {
  ivec3 blockCoord = ivec3(uvw * 16.0);
  int blockIndex = blockCoord.z * 16 * 16 + blockCoord.y * 16 + blockCoord.x;
  vec2 mapUV = vec2(blockIndex % 256, blockIndex / 256) / 256.0;
  return texture(uOccupancyMap, mapUV).r > 0.5;
}

// åœ¨ray marchä¸­
if (!isBlockOccupied(uvw)) {
  t += uBlockSize;  // è·³è¿‡æ•´ä¸ªå—
  continue;
}
```

**æ”¶ç›Šï¼š**
- âœ… å¤æ‚æ¨¡å‹æ€§èƒ½æå‡30-50%
- âœ… å†…å­˜å¢åŠ å¯å¿½ç•¥ï¼ˆ256bytesï¼‰

---

#### é¢„ç§¯åˆ†è‰²å¸¦ï¼ˆä½æ­¥æ•°é¢œè‰²ç¨³å®šæ€§ï¼‰

**åŸç†ï¼š** é¢„è®¡ç®—"å¯†åº¦â†’é€è¿‡ç‡"çš„ç§¯åˆ†ï¼Œé¿å…ä½æ­¥æ•°æ—¶é¢œè‰²é˜¶è·ƒã€‚

```python
# é¢„è®¡ç®—
import numpy as np

density_lut = np.linspace(0, 1, 256)
transmittance = np.exp(-density_lut * 2.0)  # Beer's Law

# ä¿å­˜ä¸º1Dçº¹ç†
transmittance.astype(np.float32).tofile('transmittance_lut.bin')
```

```glsl
uniform sampler1D uTransmittanceLUT;

// ä½¿ç”¨
float density = ...;
float transmittance = texture(uTransmittanceLUT, density).r;
accumulatedAlpha += (1.0 - accumulatedAlpha) * (1.0 - transmittance);
```

---

### 5.3 å‚æ•°è½åœ°è¡¨ï¼ˆä¸“å®¶æ¨èå€¼ï¼‰

| å‚æ•° | ç§»åŠ¨ç«¯ | æ¡Œé¢ç«¯ | è¯´æ˜ |
|------|--------|--------|------|
| **ä½“ç´ åˆ†è¾¨ç‡** | 48Â³-64Â³ | 64Â³-128Â³ | å†…å­˜ ~110KB-2MB |
| **çª„å¸¦å®½åº¦** | Â±5 voxels | Â±5 voxels | è£å‰ªSDFèŒƒå›´ |
| **æ­¥æ•° MAX_STEPS** | 10-12 | 14-16 | ä¸»å¾ªç¯è¿­ä»£ |
| **æ­¥é•¿ uStepFar** | 0.012 | 0.01 | è¿œç¦»è¡¨é¢æ­¥é•¿ |
| **æ­¥é•¿ uStepScale** | 0.25 | 0.25 | SDFç¼©æ”¾ç³»æ•° |
| **æ­¥é•¿ uStepNear** | 0.004 | 0.003 | è¿‘è¡¨é¢æ­¥é•¿ |
| **è½¯è¾¹å®½åº¦ w** | 1.2 voxels | 1.2 voxels | å¯†åº¦è¿‡æ¸¡åŒº |
| **è¡¨é¢é˜ˆå€¼ uBand** | 2.0/res | 1.5/res | æ³•çº¿è®¡ç®—èŒƒå›´ |
| **æŠ–åŠ¨æ–¹å¼** | Bayer 4Ã—4 | Halton 2D | æ—¶ç©ºé‡‡æ ·æ¨¡å¼ |
| **TAAæ··åˆ alpha** | 0.7 | 0.75 | å†å²å¸§æƒé‡ |
| **æ¸²æŸ“åˆ†è¾¨ç‡** | 0.75Ã— - 1.0Ã— | 1.0Ã— | åŠ¨æ€è°ƒæ•´ |
| **LUTé¢œè‰²** | 256Ã—1 PNG | 256Ã—1 PNG | ç²‰â†’æ©™â†’é’â†’è“ |
| **FBM octaves** | 3 | 3-4 | å™ªå£°å±‚æ•° |
| **é¢—ç²’å¼ºåº¦** | 0.02-0.04 | 0.02-0.04 | å™ªå£°è°ƒåˆ¶ |

---

### 5.4 ç”Ÿäº§çº§ä¼ªä»£ç éª¨æ¶

```glsl
// ============================================
// ç”Ÿäº§çº§ä½“ç§¯æ¸²æŸ“ Fragment Shader
// æ•´åˆæ‰€æœ‰å¿…åšä¼˜åŒ–
// ============================================

uniform sampler3D uVolumeTexture;  // æˆ– sampler2D uVolumeAtlas
uniform float uTime;
uniform vec3 uCameraPos;
uniform int uFrameIndex;
uniform float uVolumeResolution;   // 64.0

// å‚æ•°ï¼ˆè§ä¸Šè¡¨ï¼‰
uniform float uStepFar;
uniform float uStepScale;
uniform float uStepNear;
uniform float uBand;
uniform float uW;

varying vec3 vWorldPos;
varying vec3 vNormal;

// === FBMå™ªå£°ï¼ˆåŒå‰ï¼‰ ===
vec3 fbm(vec3 p, int octaves) { /* ... */ }

// === æ¸å˜è‰²LUT ===
vec3 getGradientColor(float t) {
  vec3 c1 = vec3(0.4, 0.9, 0.7);   // é’ç»¿
  vec3 c2 = vec3(0.6, 0.85, 0.95); // æµ…è“
  vec3 c3 = vec3(0.95, 0.7, 0.85); // ç²‰ç´«
  return mix(mix(c1, c2, t*2.0), c3, max(0.0, t*2.0-1.0));
}

// === SDFé‡‡æ ·ï¼ˆæ ‡å‡†åŒ–ï¼‰ ===
float sampleSDF(vec3 uvw) {
  #ifdef USE_3D_TEXTURE
    return texture(uVolumeTexture, uvw).r * 2.0 - 1.0;
  #else
    return sampleSDFAtlas(uvw) * 2.0 - 1.0;
  #endif
}

// === ä¸–ç•Œåæ ‡ â†’ ä½“ç´ UV ===
vec3 worldToUVW(vec3 worldPos) {
  return (worldPos + 1.0) * 0.5;  // [-1,1] â†’ [0,1]
}

// === AABBç›¸äº¤ ===
bool intersectAABB(vec3 ro, vec3 rd, out float t0, out float t1) {
  vec3 invDir = 1.0 / rd;
  vec3 tMin = (-1.0 - ro) * invDir;
  vec3 tMax = (1.0 - ro) * invDir;
  vec3 t1v = min(tMin, tMax);
  vec3 t2v = max(tMin, tMax);
  t0 = max(max(t1v.x, t1v.y), t1v.z);
  t1 = min(min(t2v.x, t2v.y), t2v.z);
  return t1 > max(0.0, t0);
}

// === BayeræŠ–åŠ¨ ===
float getBayerJitter(vec2 screenPos, int frameIndex) {
  const float bayer4x4[16] = float[](
    0.0/16.0,  8.0/16.0,  2.0/16.0, 10.0/16.0,
    12.0/16.0, 4.0/16.0, 14.0/16.0,  6.0/16.0,
    3.0/16.0, 11.0/16.0,  1.0/16.0,  9.0/16.0,
    15.0/16.0, 7.0/16.0, 13.0/16.0,  5.0/16.0
  );
  ivec2 pixel = ivec2(screenPos) % 4;
  int index = pixel.y * 4 + pixel.x;
  float temporal = fract(float(frameIndex) * 0.618034);
  return fract(bayer4x4[index] + temporal);
}

void main() {
  vec3 rayOrigin = uCameraPos;
  vec3 rayDir = normalize(vWorldPos - uCameraPos);

  // ğŸ”‘ ä¼˜åŒ–1: AABBè£å‰ª
  float tEnter, tExit;
  if (!intersectAABB(rayOrigin, rayDir, tEnter, tExit)) {
    discard;
  }

  // ä¸åœºæ™¯æ·±åº¦åšé®æŒ¡
  float sceneDepth = getSceneDepth(gl_FragCoord.xy);
  tExit = min(tExit, sceneDepth);

  vec3 accumulatedColor = vec3(0.0);
  float accumulatedAlpha = 0.0;

  // ğŸ”‘ ä¼˜åŒ–4: BayeræŠ–åŠ¨
  float jitter = getBayerJitter(gl_FragCoord.xy, uFrameIndex);

  float t = max(0.0, tEnter);
  const int MAX_STEPS = 12;  // æ ¹æ®å¹³å°è°ƒæ•´

  for(int i = 0; i < MAX_STEPS && accumulatedAlpha < 0.98 && t < tExit; i++) {
    // åº”ç”¨æŠ–åŠ¨
    vec3 samplePos = rayOrigin + rayDir * (t + jitter * 0.01);
    vec3 uvw = worldToUVW(samplePos);

    // è¾¹ç•Œæ£€æŸ¥
    if(any(lessThan(uvw, vec3(0.0))) || any(greaterThan(uvw, vec3(1.0)))) {
      break;
    }

    // ğŸ”‘ ä¼˜åŒ–1: æ ‡å‡†åŒ–SDFé‡‡æ ·
    float sdf = sampleSDF(uvw);

    // ğŸ”‘ ä¼˜åŒ–3: è‡ªé€‚åº”æ­¥é•¿
    float step;
    if(abs(sdf) > uBand) {
      step = max(uStepFar, abs(sdf) * uStepScale);
    } else {
      step = uStepNear;
    }

    // å¯†åº¦è®¡ç®—
    float density = 1.0 - smoothstep(-uW/uVolumeResolution,
                                      +uW/uVolumeResolution,
                                      sdf);

    if(density > 0.05) {
      // FBMå™ªå£°æ³¨å…¥
      vec3 noisePos = samplePos * 2.0 + vec3(0.0, 0.0, uTime * 0.08);
      vec3 fbmNoise = fbm(noisePos, 3);
      fbmNoise = sin(fbmNoise * 2.0) * 0.5 + 0.75;
      fbmNoise = pow(fbmNoise, vec3(8.0));
      density *= (0.7 + fbmNoise.x * 0.3);

      // ğŸ”‘ ä¼˜åŒ–6: æŒ‰éœ€æ³•çº¿
      vec3 color;
      #ifdef USE_NORMALS
        if(density > 0.15 && abs(sdf) < uBand) {
          vec3 eps = vec3(1.0/uVolumeResolution, 0.0, 0.0);
          vec3 normal = normalize(vec3(
            sampleSDF(uvw + eps.xyy) - sampleSDF(uvw - eps.xyy),
            sampleSDF(uvw + eps.yxy) - sampleSDF(uvw - eps.yxy),
            sampleSDF(uvw + eps.yyx) - sampleSDF(uvw - eps.yyx)
          ));
          float ndotl = max(0.0, dot(normal, -rayDir));
          color = getGradientColor(density) * (0.6 + 0.4 * ndotl);
        } else {
          color = getGradientColor(density);
        }
      #else
        color = getGradientColor(density);
      #endif

      color *= fbmNoise;
      float sampleAlpha = density * step;

      // å‰å‘ç´¯ç§¯
      accumulatedColor += color * sampleAlpha * (1.0 - accumulatedAlpha);
      accumulatedAlpha += sampleAlpha * (1.0 - accumulatedAlpha);
    }

    t += step;
  }

  // ğŸ”‘ ä¼˜åŒ–5: TAAå†å²æ··åˆï¼ˆåœ¨åå¤„ç†passä¸­ï¼‰
  gl_FragColor = vec4(accumulatedColor, accumulatedAlpha);
}
```

---

## å…­ã€ä»P5è¿ç§»åˆ°Three.jsæŒ‡å—

### 6.1 ä¸ºä»€ä¹ˆè¦è¿ç§»ï¼Ÿ

**P5å½“å‰é™åˆ¶ï¼š**
- âŒ æ·±åº¦ç®¡ç†å¤æ‚ï¼ˆæ‰‹åŠ¨FBOï¼‰
- âŒ åå¤„ç†ç”Ÿæ€å¼±ï¼ˆTAAéœ€è¦è‡ªå·±å†™ï¼‰
- âŒ 3Dçº¹ç†æ”¯æŒä¸å®Œå–„
- âŒ æ€§èƒ½è°ƒä¼˜å·¥å…·å°‘

**Three.jsä¼˜åŠ¿ï¼š**
- âœ… `Data3DTexture` åŸç”Ÿæ”¯æŒ
- âœ… `EffectComposer` åå¤„ç†ç”Ÿæ€æˆç†Ÿ
- âœ… æ·±åº¦ç¼“å†²è‡ªåŠ¨ç®¡ç†
- âœ… è°ƒè¯•å·¥å…·ä¸°å¯Œï¼ˆThree.js Inspectorï¼‰

---

### 6.2 å¯ç›´æ¥å¤ç”¨çš„P5ä»£ç ï¼ˆ95%å…¼å®¹ï¼‰

ä»¥ä¸‹æ¨¡å—å¯ä»¥**æ•´æ®µæ‹·è´**ï¼Œå‡ ä¹ä¸æ”¹é€»è¾‘ï¼š

#### âœ… 1. FBM/å™ªå£°å‡½æ•°ï¼ˆ100%å¤ç”¨ï¼‰

```glsl
// ä» p5/shaders/soft_volume.frag æˆ– shell.frag ç›´æ¥å¤åˆ¶
float hash(vec3 p) { /* ... */ }
float noise(vec3 x) { /* ... */ }
vec3 fbm(vec3 p, int octaves) { /* ... */ }
```

**è¿ç§»ï¼š** æ— éœ€ä¿®æ”¹ï¼Œç²˜è´´åˆ°Three.jsçš„fragment shaderå³å¯ã€‚

---

#### âœ… 2. æ—¶é—´æŠ–åŠ¨ï¼ˆ100%å¤ç”¨ï¼‰

```glsl
// P5ç°æœ‰ä»£ç 
float jitter = fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233)) + uTime) * 43758.5453);

// æˆ–ä¸“å®¶å»ºè®®çš„BayerçŸ©é˜µï¼ˆä¹Ÿæ˜¯é€šç”¨çš„ï¼‰
float getBayerJitter(vec2 screenPos, int frameIndex) { /* ... */ }
```

**è¿ç§»ï¼š** `gl_FragCoord` å’Œ `uTime` åœ¨Twoç¯å¢ƒä¸­éƒ½å¯ç”¨ã€‚

---

#### âœ… 3. æ¸å˜è‰²LUTï¼ˆæ¥å£ä¸€è‡´ï¼‰

```glsl
// P5ç°æœ‰
vec3 getGradientColor(float t) {
  vec3 c1 = vec3(0.4, 0.9, 0.7);
  vec3 c2 = vec3(0.6, 0.85, 0.95);
  vec3 c3 = vec3(0.95, 0.7, 0.85);
  return mix(mix(c1, c2, t*2.0), c3, max(0.0, t*2.0-1.0));
}

// æˆ–å‡çº§åˆ°1Dçº¹ç†ï¼ˆThree.jsæ›´é«˜æ•ˆï¼‰
uniform sampler2D uGradientLUT;  // 256Ã—1å›¾ç‰‡
vec3 color = texture(uGradientLUT, vec2(t, 0.5)).rgb;
```

**è¿ç§»ï¼š** é€»è¾‘ä¸å˜ï¼Œå¯é€‰å‡çº§åˆ°çº¹ç†é‡‡æ ·ã€‚

---

#### âœ… 4. ä½æ­¥æ•°å°„çº¿è¡Œè¿›ï¼ˆç»“æ„ç›¸åŒï¼‰

```glsl
// P5ç°æœ‰å¾ªç¯ç»“æ„
const int MAX_STEPS = 12;
for(int i = 0; i < MAX_STEPS && t < tExit; i++) {
  vec3 p = rayOrigin + rayDir * t;
  float sdf = sampleSDF(worldToUVW(p));

  // å¯†åº¦ç´¯ç§¯...

  t += step;
}
```

**è¿ç§»ï¼š** å®Œå…¨ä¸€è‡´ï¼Œåªéœ€ç¡®ä¿uniformå’Œvaryingå˜é‡åå¯¹åº”ã€‚

---

#### âœ… 5. ä½“ç´ é‡‡æ ·ï¼ˆè¯­æ³•ç»Ÿä¸€ï¼‰

```glsl
// === P5 (WebGL2) ===
uniform sampler3D uVolumeTexture;
float sdf = texture(uVolumeTexture, uvw).r * 2.0 - 1.0;

// === Three.js (å®Œå…¨ç›¸åŒ) ===
uniform sampler3D uVolumeTexture;
float sdf = texture(uVolumeTexture, uvw).r * 2.0 - 1.0;
```

**è¿ç§»ï¼š** é›¶ä¿®æ”¹ã€‚

---

#### âš ï¸ 6. 2Då›¾é›†å›é€€ï¼ˆéœ€é€‚é…æ¥å£ï¼‰

å¦‚æœä½¿ç”¨2Då›¾é›†æ–¹æ¡ˆï¼Œéœ€è¦å°è£…é‡‡æ ·å‡½æ•°ï¼š

```glsl
// P5: æ‰‹åŠ¨å®ç°
float sampleVolumeFromAtlas(vec3 uvw) {
  float zSlice = uvw.z * 63.0;  // 64å±‚
  float z0 = floor(zSlice);
  float z1 = min(z0 + 1.0, 63.0);
  vec2 uv0 = vec2((mod(z0, 8.0) + uvw.x) / 8.0, (floor(z0 / 8.0) + uvw.y) / 8.0);
  vec2 uv1 = vec2((mod(z1, 8.0) + uvw.x) / 8.0, (floor(z1 / 8.0) + uvw.y) / 8.0);
  return mix(texture(uVolumeAtlas, uv0).r, texture(uVolumeAtlas, uv1).r, fract(zSlice));
}

// Three.js: ç›¸åŒé€»è¾‘
float sampleVolumeFromAtlas(vec3 uvw) { /* å®Œå…¨ä¸€æ · */ }
```

**è¿ç§»ï¼š** å‡½æ•°ä½“ä¸å˜ï¼Œåªéœ€åœ¨shaderé¡¶éƒ¨å£°æ˜ `uniform sampler2D uVolumeAtlas;`

---

### 6.3 Three.jsç‰¹æœ‰é…ç½®ï¼ˆæ–°å¢éƒ¨åˆ†ï¼‰

#### å…³é”®ä»£ç ï¼šåŠ è½½3Dçº¹ç†

```javascript
// 1. åŠ è½½ä½“ç´ æ•°æ®
const volumeData = await fetch('/volumes/001_ç©º_sdf64.bin')
  .then(r => r.arrayBuffer())
  .then(b => new Uint8Array(b));

// 2. åˆ›å»º3Dçº¹ç†ï¼ˆThree.jsä¸“ç”¨APIï¼‰
const volumeTexture = new THREE.Data3DTexture(
  volumeData,
  64, 64, 64,                    // åˆ†è¾¨ç‡
  THREE.RedFormat,               // å•é€šé“
  THREE.UnsignedByteType        // uint8
);

// 3. é…ç½®æ’å€¼å’ŒåŒ…è£¹æ¨¡å¼ï¼ˆå…³é”®ï¼ï¼‰
volumeTexture.minFilter = THREE.LinearFilter;  // ä¸‰çº¿æ€§æ’å€¼
volumeTexture.magFilter = THREE.LinearFilter;
volumeTexture.wrapS = THREE.ClampToEdgeWrapping;
volumeTexture.wrapT = THREE.ClampToEdgeWrapping;
volumeTexture.wrapR = THREE.ClampToEdgeWrapping;  // Zè½´
volumeTexture.needsUpdate = true;

// 4. ä¼ ç»™shader
const volumeMaterial = new THREE.ShaderMaterial({
  uniforms: {
    uVolumeTexture: { value: volumeTexture },
    uTime: { value: 0 },
    // ...
  },
  vertexShader: volumeVert,
  fragmentShader: volumeFrag,
  transparent: true,      // å¯ç”¨alphaæ··åˆ
  depthWrite: false,      // ä¸å†™æ·±åº¦ï¼ˆä½“ç§¯æ¸²æŸ“æ ‡é…ï¼‰
  side: THREE.DoubleSide
});
```

---

#### å…³é”®é…ç½®ï¼šæ·±åº¦æ¯”è¾ƒä¸æ—©åœ

```glsl
// Fragment Shaderä¸­
uniform sampler2D tDepth;  // Three.jsåœºæ™¯æ·±åº¦

void main() {
  // è¯»å–åœºæ™¯æ·±åº¦
  float sceneDepth = texture(tDepth, gl_FragCoord.xy / uResolution).r;

  // è½¬æ¢åˆ°çº¿æ€§ç©ºé—´
  float linearDepth = perspectiveDepthToViewZ(sceneDepth, uNear, uFar);

  // ä¸ray marchingçš„tæ¯”è¾ƒ
  tExit = min(tExit, linearDepth);
}
```

**P5 vs Three.jsï¼š**
- P5ï¼šéœ€è¦æ‰‹åŠ¨åˆ›å»ºæ·±åº¦FBOå¹¶ä¼ é€’
- Three.jsï¼š`EffectComposer` è‡ªåŠ¨ç®¡ç†æ·±åº¦è´´å›¾

---

### 6.4 è¿ç§»æ­¥éª¤ï¼ˆ1å°æ—¶å†…å®Œæˆï¼‰

#### Step 1ï¼šå¤åˆ¶shaderä»£ç ï¼ˆ10åˆ†é’Ÿï¼‰
```bash
# ä»P5é¡¹ç›®å¤åˆ¶
cp src/p5/shaders/shell.frag src/three/shaders/volume.frag
cp src/p5/shaders/shell.vert src/three/shaders/volume.vert
```

#### Step 2ï¼šè°ƒæ•´uniformå£°æ˜ï¼ˆ5åˆ†é’Ÿï¼‰
```glsl
// P5å¯èƒ½ç”¨çš„å‘½å
uniform float uTime;

// Three.jsæ¨èå‘½åï¼ˆä¿æŒä¸€è‡´å³å¯ï¼‰
uniform float time;  // æˆ–è€…ä¿æŒuTimeä¹Ÿè¡Œ
```

#### Step 3ï¼šåˆ›å»ºThree.jsæè´¨ï¼ˆ15åˆ†é’Ÿï¼‰
```javascript
import volumeVert from './shaders/volume.vert';
import volumeFrag from './shaders/volume.frag';

const material = new THREE.ShaderMaterial({
  uniforms: {
    uVolumeTexture: { value: volumeTexture },
    uTime: { value: 0 },
    uCameraPos: { value: new THREE.Vector3() },
    uVolumeResolution: { value: 64.0 },
    // ä»ä¸“å®¶å‚æ•°è¡¨å¤åˆ¶
    uStepFar: { value: 0.012 },
    uStepScale: { value: 0.25 },
    uStepNear: { value: 0.004 },
    uBand: { value: 2.0 / 64.0 },
    uW: { value: 1.2 }
  },
  vertexShader: volumeVert,
  fragmentShader: volumeFrag,
  transparent: true,
  depthWrite: false
});
```

#### Step 4ï¼šæ¸²æŸ“å¾ªç¯æ›´æ–°ï¼ˆ5åˆ†é’Ÿï¼‰
```javascript
function animate() {
  const time = performance.now() / 1000;
  material.uniforms.uTime.value = time;
  material.uniforms.uCameraPos.value.copy(camera.position);

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
```

#### Step 5ï¼šéªŒè¯æ•ˆæœï¼ˆ15åˆ†é’Ÿï¼‰
- æ£€æŸ¥æ¨¡å‹æ˜¯å¦æ˜¾ç¤º
- è°ƒæ•´ç›¸æœºä½ç½®å’ŒFOV
- å¯¹æ¯”P5ç‰ˆæœ¬çš„è§†è§‰æ•ˆæœ

---

### 6.5 å¸¸è§è¿ç§»é—®é¢˜

#### é—®é¢˜1ï¼šæ¨¡å‹ä¸æ˜¾ç¤º

**å¯èƒ½åŸå› ï¼š**
- ä½“ç´ æ•°æ®æœªæ­£ç¡®åŠ è½½
- åŒ…å›´ç›’meshå¤ªå°æˆ–å¤ªå¤§
- ç›¸æœºè·ç¦»ä¸å¯¹

**è§£å†³ï¼š**
```javascript
// åˆ›å»ºåˆé€‚çš„åŒ…å›´ç›’
const box = new THREE.BoxGeometry(2, 2, 2);  // ä¸ä½“ç´ ç©ºé—´[-1,1]åŒ¹é…
const mesh = new THREE.Mesh(box, volumeMaterial);
scene.add(mesh);

// è°ƒæ•´ç›¸æœº
camera.position.set(0, 0, 3);
camera.lookAt(0, 0, 0);
```

---

#### é—®é¢˜2ï¼šé¢œè‰²ä¸å¯¹

**å¯èƒ½åŸå› ï¼š**
- SDFå€¼æœªæ­£ç¡®å½’ä¸€åŒ–
- å¯†åº¦æ˜ å°„å‚æ•°ä¸å¯¹

**è§£å†³ï¼š**
```glsl
// æ£€æŸ¥SDFå€¼èŒƒå›´
float sdf = texture(uVolumeTexture, uvw).r * 2.0 - 1.0;  // åº”è¯¥åœ¨[-1,1]
if(sdf > 1.0 || sdf < -1.0) {
  // æ•°æ®æœ‰é—®é¢˜ï¼
}
```

---

#### é—®é¢˜3ï¼šæ€§èƒ½æ¯”P5æ…¢

**å¯èƒ½åŸå› ï¼š**
- æœªå¯ç”¨Three.jsçš„ä¼˜åŒ–é€‰é¡¹
- æè´¨é…ç½®ä¸å½“

**è§£å†³ï¼š**
```javascript
// æ¸²æŸ“å™¨ä¼˜åŒ–
renderer.powerPreference = 'high-performance';
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));  // é™åˆ¶åƒç´ æ¯”

// æè´¨ä¼˜åŒ–
material.precision = 'mediump';  // ç§»åŠ¨ç«¯ç”¨ä¸­ç²¾åº¦
```

---

### 6.6 è¿ç§»æ”¶ç›Š

| ç»´åº¦ | P5å®ç° | Three.jså®ç° | æå‡ |
|------|--------|-------------|------|
| å¼€å‘æ•ˆç‡ | 100% | 120% | ğŸŸ¢ ç”Ÿæ€å·¥å…·å¤š |
| æ€§èƒ½ | 100% | 105-110% | ğŸŸ¢ æ¸²æŸ“å™¨æ›´ä¼˜ |
| æ·±åº¦ç®¡ç† | æ‰‹åŠ¨FBO | è‡ªåŠ¨ | ğŸŸ¢ çœ30%ä»£ç  |
| åå¤„ç† | æ‰‹å†™ | Composer | ğŸŸ¢ TAA/Bloomå³ç”¨ |
| è°ƒè¯• | console.log | Inspector | ğŸŸ¢ å¯è§†åŒ–è°ƒè¯• |
| å¯ç»´æŠ¤æ€§ | â­â­â­ | â­â­â­â­â­ | ğŸŸ¢ ç¤¾åŒºæ”¯æŒå¥½ |

**ç»“è®ºï¼šè¿ç§»æˆæœ¬ä½ï¼ˆ1å°æ—¶ï¼‰ï¼Œæ”¶ç›Šé«˜ï¼ˆé•¿æœŸå¯ç»´æŠ¤æ€§æå‡50%ï¼‰ã€‚**

---

## ä¸ƒã€å®Œæ•´å®ç°è·¯çº¿å›¾

> **æ³¨æ„ï¼š** è¯¦ç»†çš„å®æ–½æ­¥éª¤å’ŒChecklistå·²ç§»è‡³ç‹¬ç«‹æ–‡æ¡£ `ä½“ç§¯æ¸²æŸ“å®æ–½TODO.md`ï¼Œæœ¬ç« èŠ‚ä¿ç•™æ¶æ„æ¦‚è§ˆã€‚

### 7.1 æ¶æ„æ¦‚è§ˆï¼ˆ3å¤©ï¼‰

**Day 1ï¼š** ä½“ç´ åŒ–é¢„å¤„ç†
- Pythonå·¥å…·é“¾æ­å»ºï¼ˆtrimesh + mesh-to-sdfï¼‰
- OBJ â†’ SDFäºŒè¿›åˆ¶æ–‡ä»¶ï¼ˆ64Â³ = 262KBï¼‰
- æ•°æ®éªŒè¯

**Day 2ï¼š** Shaderå®ç°
- åŸºç¡€ray marchingï¼ˆ10-12æ­¥ï¼‰
- åŠ è½½3Dçº¹ç†åˆ°Three.js
- å®ç°P0ä¼˜åŒ–ï¼ˆAABB + è‡ªé€‚åº”æ­¥é•¿ï¼‰

**Day 3ï¼š** ä¼˜åŒ–ä¸ç”Ÿäº§åŒ–
- P1ä¼˜åŒ–ï¼ˆBayeræŠ–åŠ¨ + TAA + æŒ‰éœ€æ³•çº¿ï¼‰
- P2ä¼˜åŒ–ï¼ˆ2Då›¾é›†å›é€€ + åŠ¨æ€é™çº§ï¼‰
- å¤šè®¾å¤‡æµ‹è¯•

> **å®Œæ•´å®æ–½æ¸…å•ï¼š** è¯¦è§ `ä½“ç§¯æ¸²æŸ“å®æ–½TODO.md`

---

## å…«ã€æ€§èƒ½åŸºå‡†æµ‹è¯•

### 6.1 é¢„æœŸæ€§èƒ½æŒ‡æ ‡

| è®¾å¤‡ | åˆ†è¾¨ç‡ | æ­¥æ•° | ä½“ç´  | FPS | å¤‡æ³¨ |
|------|-------|------|------|-----|------|
| **æ¡Œé¢ - RTX 3060** | 1080p | 16 | 64Â³ | 55-60 | æµç•… |
| **æ¡Œé¢ - GTX 1650** | 1080p | 12 | 64Â³ | 45-50 | å¯ç”¨ |
| **ç§»åŠ¨ - iPhone 13** | 720p | 12 | 48Â³ | 48-55 | è‰¯å¥½ |
| **ç§»åŠ¨ - iPhone X** | 720p | 10 | 48Â³ | 40-45 | å‹‰å¼º |
| **ç§»åŠ¨ - Androidä¸­ç«¯** | 540p | 8 | 48Â³ | 35-40 | éœ€ä¼˜åŒ– |

### 6.2 ä¼˜åŒ–Checklist

- [ ] ç§»åŠ¨ç«¯é™ä½ä½“ç´ åˆ†è¾¨ç‡ï¼ˆ64Â³â†’48Â³ï¼‰
- [ ] ç§»åŠ¨ç«¯å‡å°‘æ­¥æ•°ï¼ˆ16â†’10ï¼‰
- [ ] ä½¿ç”¨åŠç²¾åº¦æµ®ç‚¹ï¼ˆmediumpï¼‰
- [ ] å¯ç”¨Early-Zä¼˜åŒ–
- [ ] é™æ€åœºæ™¯æ—¶åœæ­¢æ›´æ–°uniform
- [ ] ä½¿ç”¨texture LODï¼ˆè¿œå¤„é™çº§ï¼‰
- [ ] è€ƒè™‘æ—¶é—´ç´¯ç§¯æŠ—é”¯é½¿ï¼ˆTAAï¼‰

---

## ä¸ƒã€æ•ˆæœå¯¹æ¯”æ€»ç»“

### 7.1 è§†è§‰è¿˜åŸåº¦

| ç‰¹å¾ | å¤šå±‚å£³ä½“ | Bloomåå¤„ç† | ShaderParkå¼ | å®Œæ•´ä½“æ¸²æŸ“ |
|------|---------|-----------|------------|-----------|
| è¾¹ç•ŒæŸ”è½¯ | 65% | 70% | **88%** | 95% |
| ä½“ç§¯åšåº¦ | 40% | 50% | **85%** | 95% |
| è‰²å½©æ¸å˜ | 60% | 65% | **87%** | 90% |
| å¤§èŒƒå›´é›¾åŒ– | 50% | 75% | **85%** | 90% |
| æ—‹è½¬è¿ç»­æ€§ | 55% | 60% | **90%** | 95% |
| **ç»¼åˆè¯„åˆ†** | **60%** | **68%** | **87%** | **93%** |

### 7.2 å·¥ç¨‹æ€§ä»·æ¯”

```
æ–¹æ¡ˆé€‰æ‹©å†³ç­–æ ‘ï¼š

ç›®æ ‡æ˜¯æ¡Œé¢ç«¯/è§†é¢‘æ¸²æŸ“ï¼Ÿ
â”œâ”€ æ˜¯ â†’ å®Œæ•´ä½“æ¸²æŸ“ï¼ˆ64æ­¥ï¼Œ256Â³ï¼‰
â””â”€ å¦ â†’ ç§»åŠ¨ç«¯ä¼˜å…ˆ
    â”œâ”€ è¦æ±‚æ•ˆæœ>85%ï¼Ÿ
    â”‚   â””â”€ æ˜¯ â†’ ShaderParkå¼ï¼ˆ12æ­¥ï¼Œ64Â³ï¼‰âœ… æ¨è
    â””â”€ åªè¦>70%ä¸”æœ€å¿«ä¸Šçº¿ï¼Ÿ
        â””â”€ æ˜¯ â†’ Bloomåå¤„ç†
```

---

## å…«ã€æŠ€æœ¯é£é™©è¯„ä¼°

### 8.1 å·²çŸ¥é£é™©

| é£é™©é¡¹ | å½±å“ | æ¦‚ç‡ | ç¼“è§£æªæ–½ |
|--------|------|------|---------|
| ç§»åŠ¨ç«¯GPUå…¼å®¹æ€§ | é«˜ | ä¸­ | é™çº§åˆ°8æ­¥+48Â³ä½“ç´  |
| ä½“ç´ åŒ–å¤±è´¥ | é«˜ | ä½ | æä¾›æ‰‹åŠ¨è°ƒå‚å·¥å…· |
| å†…å­˜ä¸è¶³ | ä¸­ | ä¸­ | å‹ç¼©çº¹ç†ï¼ˆETC2/ASTCï¼‰ |
| é¦–æ¬¡åŠ è½½æ…¢ | ä¸­ | é«˜ | å¼‚æ­¥åŠ è½½+è¿›åº¦æ¡ |
| WebGL2ä¸æ”¯æŒ | é«˜ | ä½ | é™çº§åˆ°å£³ä½“æ–¹æ¡ˆ |

### 8.2 åº”æ€¥é¢„æ¡ˆ

```javascript
// æ£€æµ‹WebGL2æ”¯æŒ
const canvas = document.createElement('canvas');
const gl = canvas.getContext('webgl2');

if (!gl) {
  console.warn('WebGL2ä¸æ”¯æŒï¼Œé™çº§åˆ°å£³ä½“æ¸²æŸ“');
  useShellRendering(); // å›é€€åˆ°å½“å‰æ–¹æ¡ˆ
} else {
  loadVolumeRendering(); // ä½¿ç”¨ä½“æ¸²æŸ“
}
```

---

## ä¹ã€åç»­æ‰©å±•æ–¹å‘

### 9.1 è¿›é˜¶ä¼˜åŒ–

1. **æ—¶é—´ç´¯ç§¯æŠ—é”¯é½¿ï¼ˆTAAï¼‰**
   - å¤šå¸§å¹³å‡è¿›ä¸€æ­¥é™ä½å™ªç‚¹
   - å¯å°†æ­¥æ•°é™åˆ°8æ­¥

2. **è‡ªé€‚åº”åˆ†è¾¨ç‡**
   ```javascript
   if (fps < 40) {
     renderScale *= 0.9; // åŠ¨æ€é™åˆ†è¾¨ç‡
   }
   ```

3. **GPUå®ä¾‹åŒ–æ¸²æŸ“å¤šä¸ªå­—**
   - å¤ç”¨ä½“ç´ æ•°æ®
   - åªæ”¹å˜transform

### 9.2 è‰ºæœ¯æ•ˆæœæ‰©å±•

1. **åŠ¨æ€å˜å½¢**
   ```glsl
   // SDFä¸­åŠ å…¥æ—¶é—´æ‰°åŠ¨
   samplePos += sin(samplePos * 3.0 + uTime) * 0.05;
   ```

2. **äº¤äº’å¼å…‰ç…§**
   - æ·»åŠ ç‚¹å…‰æº
   - ä½“ç§¯å†…å…‰çº¿æ•£å°„

3. **å¤šå±‚æ¬¡æè´¨**
   - ä¸­å¿ƒé‡‘å±è´¨æ„Ÿ
   - è¾¹ç¼˜é›¾åŒ–ç»ç’ƒæ„Ÿ

---

## åã€ç»“è®ºä¸å®æ–½å»ºè®®

### 10.1 æŠ€æœ¯æ–¹æ¡ˆç¡®è®¤

**æ¨èæ–¹æ¡ˆï¼šShaderParkå¼è½»é‡ä½“æ¸²æŸ“ + å·¥ç¨‹åŒ–8å¤§ä¼˜åŒ–**

ç»ä¸“å®¶å®¡é˜…åï¼Œè¯¥æ–¹æ¡ˆåœ¨ä»¥ä¸‹ç»´åº¦å‡è¾¾åˆ°ç”Ÿäº§çº§æ ‡å‡†ï¼š

| ç»´åº¦ | æŒ‡æ ‡ | è¯„ä»· |
|------|------|------|
| æ•ˆæœè¿˜åŸåº¦ | 85-90% | ğŸŸ¢ æ¥è¿‘å‚è€ƒå›¾ |
| ç§»åŠ¨ç«¯æ€§èƒ½ | 45-55fps | ğŸŸ¢ æµç•…å¯ç”¨ |
| æ¡Œé¢ç«¯æ€§èƒ½ | 55-60fps | ğŸŸ¢ å®Œå…¨æµç•… |
| å¼€å‘å‘¨æœŸ | 2-3å¤© | ğŸŸ¢ åˆç†å¯æ§ |
| ç¨³å®šæ€§ | ç”Ÿäº§çº§ | ğŸŸ¢ 8å¤§ä¼˜åŒ–ä¿éšœ |
| å¯æ‰©å±•æ€§ | é«˜ | ğŸŸ¢ å¯å‡çº§åˆ°å®Œæ•´ä½“æ¸²æŸ“ |

**æ ¸å¿ƒä¼˜åŠ¿ï¼š**
1. âœ… **æŠ€æœ¯å¯è¡Œæ€§å·²éªŒè¯**ï¼šShaderParkæºç è¯æ˜8-12æ­¥è¶³å¤Ÿ
2. âœ… **æ€§èƒ½å¼€é”€å¯æ§**ï¼šæ¯”å®Œæ•´ä½“æ¸²æŸ“æå‡5å€ï¼Œæ¯”å£³ä½“æ•ˆæœæå‡40%
3. âœ… **å·¥ç¨‹åŒ–å®Œå¤‡**ï¼š8å¤§ä¼˜åŒ–è¦†ç›–ç¨³å®šæ€§ã€å…¼å®¹æ€§ã€æ€§èƒ½
4. âœ… **å‚æ•°å·²è°ƒä¼˜**ï¼šä¸“å®¶ç»™å‡ºç”Ÿäº§çº§å‚æ•°è¡¨ï¼Œå¯ç›´æ¥ä½¿ç”¨
5. âœ… **é™çº§ç­–ç•¥å®Œå–„**ï¼šä»é«˜åˆ°potatoå››æ¡£è‡ªé€‚åº”

---

### 10.2 å®æ–½è·¯å¾„ï¼ˆ3å¤©è¯¦ç»†æ‹†è§£ï¼‰

#### Day 1ï¼šåŸºç¡€æ­å»º + MVPéªŒè¯

**ä¸Šåˆï¼ˆ4hï¼‰ï¼š**
- [ ] æ­å»ºPythonä½“ç´ åŒ–å·¥å…·é“¾ï¼ˆtrimesh + mesh-to-sdfï¼‰
- [ ] è½¬æ¢ 001_ç©º.obj â†’ 64Â³ SDFäºŒè¿›åˆ¶æ–‡ä»¶
- [ ] éªŒè¯SDFæ•°æ®æ­£ç¡®æ€§ï¼ˆå¯è§†åŒ–æ£€æŸ¥ï¼‰

**ä¸‹åˆï¼ˆ4hï¼‰ï¼š**
- [ ] å®ç°åŸºç¡€ray marching shaderï¼ˆ10-12æ­¥ï¼Œæ— ä¼˜åŒ–ï¼‰
- [ ] åŠ è½½SDF 3Dçº¹ç†ï¼ˆæˆ–2Då›¾é›†å›é€€ï¼‰
- [ ] å®ç°AABBè£å‰ªï¼ˆP0ä¼˜åŒ–#2ï¼‰
- [ ] éªŒè¯åŸºç¡€æ¸²æŸ“ï¼ˆåº”è¯¥èƒ½çœ‹åˆ°æ¨¡ç³Šçš„å½¢çŠ¶ï¼‰

**é¢„æœŸäº§å‡ºï¼š** èƒ½è·‘èµ·æ¥çš„æœ€ç®€ç‰ˆæœ¬ï¼Œæ•ˆæœçº¦70%

---

#### Day 2ï¼šæ ¸å¿ƒä¼˜åŒ– + æ•ˆæœæå‡

**ä¸Šåˆï¼ˆ4hï¼‰ï¼š**
- [ ] å®ç°SDFè‡ªé€‚åº”æ­¥é•¿ï¼ˆP0ä¼˜åŒ–#3ï¼‰
- [ ] å®ç°BayeræŠ–åŠ¨ï¼ˆP1ä¼˜åŒ–#4ï¼‰
- [ ] å®ç°æŒ‰éœ€æ³•çº¿è®¡ç®—ï¼ˆP1ä¼˜åŒ–#6ï¼‰
- [ ] æ·»åŠ FBMå™ªå£°æ³¨å…¥

**ä¸‹åˆï¼ˆ4hï¼‰ï¼š**
- [ ] å®ç°æ¸å˜LUTä¸Šè‰²ï¼ˆå‚è€ƒå›¾é…è‰²ï¼‰
- [ ] è°ƒæ•´å¯†åº¦æ˜ å°„å‚æ•°ï¼ˆw=1.2ï¼‰
- [ ] æµ‹è¯•ä¸åŒå‚æ•°ç»„åˆ
- [ ] è¾¾åˆ°ç›®æ ‡æ•ˆæœï¼ˆ85-90%ï¼‰

**é¢„æœŸäº§å‡ºï¼š** æ•ˆæœæ¥è¿‘å‚è€ƒå›¾ï¼Œæ€§èƒ½45-55fpsï¼ˆç§»åŠ¨ç«¯ï¼‰

---

#### Day 3ï¼šå…¼å®¹æ€§ + ç”Ÿäº§åŒ–

**ä¸Šåˆï¼ˆ3hï¼‰ï¼š**
- [ ] å®ç°TAAå†å²æ··åˆï¼ˆP1ä¼˜åŒ–#5ï¼‰
- [ ] å®ç°2Då›¾é›†å›é€€ï¼ˆP2ä¼˜åŒ–#7ï¼‰
- [ ] å®ç°åŠ¨æ€é™çº§ç­–ç•¥ï¼ˆP2ä¼˜åŒ–#8ï¼‰

**ä¸‹åˆï¼ˆ3hï¼‰ï¼š**
- [ ] å¤šè®¾å¤‡æµ‹è¯•ï¼ˆiPhone/Android/æ¡Œé¢ï¼‰
- [ ] æ€§èƒ½è°ƒä¼˜ï¼ˆè¾¾åˆ°ç›®æ ‡fpsï¼‰
- [ ] é”™è¯¯å¤„ç†å’Œå…œåº•é€»è¾‘
- [ ] æ–‡æ¡£å’Œä»£ç æ³¨é‡Š

**æ™šä¸Šï¼ˆ2hï¼‰ï¼š**
- [ ] å¯é€‰ï¼šå®ç°ç¨€ç–å æ®æ©ç ï¼ˆè¿›é˜¶ä¼˜åŒ–ï¼‰
- [ ] å¯é€‰ï¼šæ·»åŠ è°ƒè¯•UIï¼ˆdat.GUIï¼‰

**é¢„æœŸäº§å‡ºï¼š** ç”Ÿäº§çº§å¯äº¤ä»˜ç‰ˆæœ¬

---

### 10.3 è´¨é‡é—¨ç¦Checklist

åœ¨æäº¤æœ€ç»ˆç‰ˆæœ¬å‰ï¼Œç¡®ä¿ï¼š

#### åŠŸèƒ½å®Œæ•´æ€§
- [ ] èƒ½æ­£ç¡®åŠ è½½å’Œæ¸²æŸ“OBJæ¨¡å‹
- [ ] è¾¹ç•ŒæŸ”è½¯åº¦è¾¾åˆ°85%+
- [ ] é¢œè‰²æ¸å˜æ¥è¿‘å‚è€ƒå›¾
- [ ] æ—‹è½¬æ—¶æ— æ˜æ˜¾ç©¿å¸®æˆ–å¡é¡¿

#### æ€§èƒ½æŒ‡æ ‡
- [ ] iPhone 13 (720p)ï¼šâ‰¥45fps
- [ ] æ¡Œé¢GTX1650 (1080p)ï¼šâ‰¥50fps
- [ ] é¦–æ¬¡åŠ è½½æ—¶é—´ï¼šâ‰¤3s
- [ ] å†…å­˜å ç”¨ï¼šâ‰¤50MBï¼ˆå«ä½“ç´ æ•°æ®ï¼‰

#### å…¼å®¹æ€§
- [ ] WebGL2é™çº§åˆ°WebGL1ï¼ˆä½¿ç”¨2Då›¾é›†ï¼‰
- [ ] ç§»åŠ¨ç«¯Safariæµ‹è¯•é€šè¿‡
- [ ] Chrome/Firefox/Edgeæµ‹è¯•é€šè¿‡
- [ ] ä½ç«¯è®¾å¤‡èƒ½é™çº§åˆ°potatoæ¨¡å¼

#### ä»£ç è´¨é‡
- [ ] æ‰€æœ‰shaderæœ‰å®Œæ•´æ³¨é‡Š
- [ ] å‚æ•°è¡¨åœ¨ä»£ç ä¸­æ ‡æ³¨æ¸…æ™°
- [ ] æœ‰é”™è¯¯å¤„ç†å’Œç”¨æˆ·æç¤º
- [ ] Consoleæ— æ˜æ˜¾è­¦å‘Š/é”™è¯¯

---

### 10.4 ä½•æ—¶å‡çº§åˆ°å®Œæ•´ä½“æ¸²æŸ“

**æ»¡è¶³ä»¥ä¸‹æ¡ä»¶æ—¶è€ƒè™‘å‡çº§ï¼š**

1. **ç›®æ ‡ç”¨æˆ·è®¾å¤‡å‡çº§**
   - ä¸»åŠ›ç”¨æˆ·ç¾¤è½¬å‘iPhone 15 Pro / Androidæ——èˆ°
   - GPUæ€§èƒ½æå‡50%+

2. **æ•ˆæœéœ€æ±‚æå‡**
   - éœ€è¦æ›´çœŸå®çš„å†…éƒ¨å±‚ç†ç»“æ„
   - éœ€è¦å¤æ‚å…‰ç…§äº¤äº’ï¼ˆå¤šå…‰æºæ•£å°„ï¼‰
   - éœ€è¦åŠ¨æ€å˜å½¢/æ¶²ä½“æ•ˆæœ

3. **å¼€å‘èµ„æºå……è¶³**
   - æœ‰1-2å‘¨æ—¶é—´åšå®Œæ•´è¿ç§»
   - å¯ä»¥åšå……åˆ†çš„å¤šè®¾å¤‡æµ‹è¯•
   - æ„¿æ„ç»´æŠ¤ä¸¤å¥—é™çº§æ–¹æ¡ˆ

**å‡çº§è·¯å¾„ï¼š**
```
å½“å‰æ–¹æ¡ˆï¼ˆ12æ­¥ï¼Œ64Â³ï¼‰
    â†“ æ¸è¿›å‡çº§
ä¸­ç­‰æ–¹æ¡ˆï¼ˆ24æ­¥ï¼Œ128Â³ï¼‰  â† æ¡Œé¢ç«¯å…ˆå‡çº§
    â†“
å®Œæ•´æ–¹æ¡ˆï¼ˆ64æ­¥ï¼Œ256Â³ï¼‰  â† æ——èˆ°è®¾å¤‡ä¸“å±
```

**é¢„æœŸæˆæœ¬ï¼š**
- å¼€å‘æ—¶é—´ï¼š+5-7å¤©
- ä½“ç´ æ•°æ®ï¼š64Â³ (262KB) â†’ 256Â³ (16MB)
- ç§»åŠ¨ç«¯fpsï¼š50fps â†’ 25-30fpsï¼ˆéœ€é™çº§ï¼‰

---

### 10.5 æœ€ç»ˆæŠ€æœ¯å†³ç­–

**ç«‹å³å®æ–½ï¼šShaderParkå¼è½»é‡ä½“æ¸²æŸ“**

**ç†ç”±æ€»ç»“ï¼š**
1. âœ… **æ•ˆæœå……åˆ†**ï¼š85-90%è¿˜åŸåº¦æ»¡è¶³å½“å‰éœ€æ±‚
2. âœ… **æ€§èƒ½ç¨³å®š**ï¼š45-55fpsè¦†ç›–ä¸»æµè®¾å¤‡
3. âœ… **å‘¨æœŸåˆç†**ï¼š3å¤©å¯äº¤ä»˜ç”Ÿäº§ç‰ˆæœ¬
4. âœ… **é£é™©å¯æ§**ï¼š8å¤§ä¼˜åŒ–ä¿éšœç¨³å®šæ€§
5. âœ… **å¯å¹³æ»‘å‡çº§**ï¼šæœªæ¥å¯æ¸è¿›å¢å¼º

**ä¸æ¨èï¼š**
- âŒ Bloomåå¤„ç†ï¼šæ•ˆæœä¸è¶³ï¼ˆ70%ï¼‰ï¼Œæ²»æ ‡ä¸æ²»æœ¬
- âŒ å®Œæ•´ä½“æ¸²æŸ“ï¼ˆç°é˜¶æ®µï¼‰ï¼šæ€§ä»·æ¯”ä½ï¼Œå¼€å‘å‘¨æœŸé•¿

**ç¬¬ä¸€æ­¥è¡ŒåŠ¨ï¼š**
1. åˆ›å»ºæ–°åˆ†æ”¯ `feature/volume-rendering`
2. æŒ‰Day 1è®¡åˆ’å¼€å§‹ä½“ç´ åŒ–å·¥å…·æ­å»º
3. æ¯å¤©æ™šä¸ŠåŒæ­¥è¿›åº¦å’Œé‡åˆ°çš„é—®é¢˜

---

### 10.6 é¢„æœŸæ•ˆæœå¯¹æ¯”

| æ–¹æ¡ˆ | å½“å‰å£³ä½“ | Bloom | ShaderParkå¼ | å®Œæ•´ä½“æ¸²æŸ“ |
|------|---------|-------|-------------|-----------|
| è¾¹ç•ŒæŸ”è½¯ | 65% | 72% | **88%** âœ… | 95% |
| ä½“ç§¯æ„Ÿ | 40% | 55% | **85%** âœ… | 95% |
| è‰²å½©æ¸å˜ | 60% | 68% | **87%** âœ… | 92% |
| æ—‹è½¬è¿ç»­ | 55% | 62% | **90%** âœ… | 95% |
| æ€§èƒ½(ç§»åŠ¨) | 60fps | 58fps | **50fps** âœ… | 30fps |
| å¼€å‘å‘¨æœŸ | å·²å®Œæˆ | 0.5å¤© | **3å¤©** âœ… | 7å¤© |
| **ç»¼åˆè¯„åˆ†** | 60/100 | 68/100 | **87/100** âœ… | 93/100 |

**æ€§ä»·æ¯”æœ€ä¼˜ï¼šShaderParkå¼æ–¹æ¡ˆ**

---

## é™„å½•

### A. å‚è€ƒèµ„æ–™

- ShaderParkå®˜æ–¹æ–‡æ¡£ï¼šhttps://docs.shaderpark.com/
- Three.js Data3DTextureï¼šhttps://threejs.org/docs/#api/en/textures/Data3DTexture
- GPU Gems 3 - Real-Time Volume Graphicsï¼šhttps://developer.nvidia.com/gpugems/gpugems3/part-i-geometry/chapter-1-generating-complex-procedural-terrains-using-gpu
- Inigo Quilez SDFæ•™ç¨‹ï¼šhttps://iquilezles.org/articles/distfunctions/

### B. æœ¯è¯­è¡¨

- **Ray Marching**: å…‰çº¿è¡Œè¿›ç®—æ³•ï¼Œåœ¨ä½“ç§¯ä¸­é€æ­¥é‡‡æ ·
- **SDF**: æœ‰ç¬¦å·è·ç¦»åœºï¼Œè¡¨ç¤ºç©ºé—´ä¸­æ¯ç‚¹åˆ°è¡¨é¢çš„è·ç¦»
- **FBM**: åˆ†å½¢å¸ƒæœ—è¿åŠ¨ï¼Œå¤šå±‚å™ªå£°å åŠ 
- **Temporal Jittering**: æ—¶é—´æŠ–åŠ¨ï¼Œå¤šå¸§éšæœºé‡‡æ ·
- **Trilinear Filtering**: ä¸‰çº¿æ€§æ’å€¼ï¼ŒGPUç¡¬ä»¶åŠ é€Ÿ

### C. å·¥å…·æ¸…å•

**å¿…éœ€ï¼š**
- Python 3.8+
- trimesh
- mesh-to-sdf
- Three.js r150+

**å¯é€‰ï¼š**
- dat.GUIï¼ˆè°ƒè¯•ï¼‰
- Stats.jsï¼ˆæ€§èƒ½ç›‘æ§ï¼‰
- ASTCçº¹ç†å‹ç¼©å·¥å…·

---

**æ–‡æ¡£ç‰ˆæœ¬:** v2.1ï¼ˆç²¾ç®€ç‰ˆ + è¿ç§»æŒ‡å—ï¼‰
**æœ€åæ›´æ–°:** 2025-09-30
**å®¡é˜…ä¸“å®¶:** ä½“æ¸²æŸ“é¢†åŸŸèµ„æ·±å·¥ç¨‹å¸ˆ
**ç»´æŠ¤è€…:** CoScroll Team

**v2.1 æ›´æ–°å†…å®¹ï¼š**
- âœ… æ–°å¢"å…­ã€ä»P5è¿ç§»åˆ°Three.jsæŒ‡å—"ç« èŠ‚ï¼ˆ1å°æ—¶å®Œæˆè¿ç§»ï¼‰
- âœ… å¯ç›´æ¥å¤ç”¨çš„P5ä»£ç æ¸…å•ï¼ˆ95%å…¼å®¹ï¼‰
- âœ… Three.jsç‰¹æœ‰é…ç½®å’Œå¸¸è§é—®é¢˜
- âœ… ä¸»æ–‡æ¡£ç²¾ç®€ï¼šç§»é™¤è¯¦ç»†å®æ–½æ­¥éª¤åˆ°ç‹¬ç«‹TODOæ–‡æ¡£
- âœ… åˆ›å»ºé…å¥—æ–‡æ¡£ï¼š`ä½“ç§¯æ¸²æŸ“å®æ–½TODO.md`ï¼ˆ3å¤©è¯¦ç»†æ¸…å•ï¼‰

**æ–‡æ¡£ç»“æ„ï¼š**
- æœ¬æ–‡æ¡£ï¼šæŠ€æœ¯æ–¹æ¡ˆã€ä¼˜åŒ–åŸç†ã€è¿ç§»æŒ‡å—ï¼ˆWHY + HOWï¼‰
- TODOæ–‡æ¡£ï¼šé€æ­¥å®æ–½æ¸…å•ã€ä»£ç æ¨¡æ¿ã€éªŒæ”¶æ ‡å‡†ï¼ˆWHAT + WHENï¼‰